{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1c152050_949413a9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-16T15:17:04Z",
      "side": 1,
      "message": "Same nits as the previous change, and also:",
      "revId": "f6078b59a5f34a0ffef8e133e76e91c8c905df41",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "960dffc1_057bc14d",
        "filename": "src/Pipeline/SpirvShaderGLSLstd450.cpp",
        "patchSetId": 5
      },
      "lineNbr": 756,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-16T15:17:04Z",
      "side": 1,
      "message": "I initially thought that the spec would state that the full-precision operation requires precision \u0027inherited\u0027 from 1.0 / sqrt(), thus forcing us to use exactly that implementation. In which case it would have been better not to handle this down at the Reactor level...\n\nHowever, the spec instead states that inversesqrt() precision is 2 ULP, while sqrt() is inherited from 1.0 / inverseqqrt(). This suggests that on GPUs inversesqrt is a native instruction, while here we\u0027re trying to use x86\u0027s native sqrt instructions.\n\nIn short, this looks fine, but let\u0027s make sure the Vulkan expectation and difference with our implementation is mentioned in the commit message so it ends up in b/169760262.",
      "range": {
        "startLine": 756,
        "startChar": 16,
        "endLine": 756,
        "endChar": 23
      },
      "revId": "f6078b59a5f34a0ffef8e133e76e91c8c905df41",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd347f8d_52eff033",
        "filename": "src/Pipeline/SpirvShaderGLSLstd450.cpp",
        "patchSetId": 5
      },
      "lineNbr": 756,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-12-16T22:13:47Z",
      "side": 1,
      "message": "Done. Let me know if I captured what you meant in the commit message.",
      "parentUuid": "960dffc1_057bc14d",
      "range": {
        "startLine": 756,
        "startChar": 16,
        "endLine": 756,
        "endChar": 23
      },
      "revId": "f6078b59a5f34a0ffef8e133e76e91c8c905df41",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b90321f_05519ee2",
        "filename": "src/Pipeline/SpirvShaderGLSLstd450.cpp",
        "patchSetId": 5
      },
      "lineNbr": 756,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-17T03:40:43Z",
      "side": 1,
      "message": "Yes, that should suffice to point out the reverse roles of sqrt and 1/sqrt vs. Vulkan\u0027s precision expectations in our x86 implementation. That is, our sqrt is more accurate than our 1/sqrt, while with Vulkan it\u0027s the inverse. We\u0027re still below the ULP requirement for each so it\u0027s totally cool.",
      "parentUuid": "bd347f8d_52eff033",
      "range": {
        "startLine": 756,
        "startChar": 16,
        "endLine": 756,
        "endChar": 23
      },
      "revId": "f6078b59a5f34a0ffef8e133e76e91c8c905df41",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    }
  ]
}