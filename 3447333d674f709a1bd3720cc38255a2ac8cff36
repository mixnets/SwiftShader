{
  "comments": [
    {
      "key": {
        "uuid": "2fcf8c2f_a095b29f",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 264,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-05-11T15:27:19Z",
      "side": 1,
      "message": "Should this not return \u0027const Value *\u0027 since it\u0027s a const member function? Normally we should provide the two overloads:\n\nconst Value *value() const { return val; }\nValue *value() { return val; }",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dec0f188_617b09e0",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 264,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-05-11T19:42:36Z",
      "side": 1,
      "message": "Being a const member function just means it\u0027s not allowed to change \u0027val\u0027 to another pointer (which is what we really care about for this class, see line 261). It doesn\u0027t mean the pointee has to remain const. Note that \u0027Value*\u0027 is a pointer to an undefined type. For LLVM, it\u0027s implemented with \u0027llvm::Value*\u0027, and all of the \u0027Builder\u0027 methods take non-const parameters of this type. Likewise for Subzero taking \u0027Operand*\u0027 and \u0027Variable*\u0027 which are almost always non-const.\n\nI suspect that\u0027s because LLVM and Subzero do modify the pointee data even for input parameters, in some cases.\n\nI\u0027m not sure if there\u0027s any value in trying to add const correctness to an undefined type, but I\u0027m open to suggestions for a follow-up change.",
      "parentUuid": "2fcf8c2f_a095b29f",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f860a9de_75442d72",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 278,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-05-11T15:27:19Z",
      "side": 1,
      "message": "I wonder if we should just call this function \u0027value\u0027 rather than \u0027rvalue\u0027. Is it important or significant to the caller that we\u0027re getting an r-value? It would make Argument consistent with LValue and RValue. In fact, we might want to derive Argument from RValue in the future so that we can pass them directly to functions that accept a RValue, and having the function named \u0027value\u0027 would mean having less to change (though I know there aren\u0027t many calls to this function).",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3bc8ead6_7cd83f28",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 278,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-05-11T19:42:36Z",
      "side": 1,
      "message": "I think it\u0027s important since, unlike C, we can\u0027t assign new values to an Argument\u003c\u003e.\n\nNote that RValue::value() returns a Value*, not a type-safe RValue\u003c\u003e like this method. So I think it\u0027s useful to make that distinction. LValue doesn\u0027t have a value() method, but a loadValue() one, which also makes an important distinction since, at least logically, one always has to load from its address to obtain the stored value.\n\nI\u0027m not sure there\u0027s much value in allowing Argument\u003c\u003e to be passed directly to functions that take RValues. Note that we can only obtain them from function.Arg\u003c0\u003e() methods, so they\u0027re nameless and the current setup encourages to immediately assign them to named lvalues. After that you never have to use the nameless ones again.",
      "parentUuid": "f860a9de_75442d72",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    }
  ]
}