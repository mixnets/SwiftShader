{
  "comments": [
    {
      "key": {
        "uuid": "2fcf8c2f_a095b29f",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 264,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-05-11T15:27:19Z",
      "side": 1,
      "message": "Should this not return \u0027const Value *\u0027 since it\u0027s a const member function? Normally we should provide the two overloads:\n\nconst Value *value() const { return val; }\nValue *value() { return val; }",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dec0f188_617b09e0",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 264,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-05-11T19:42:36Z",
      "side": 1,
      "message": "Being a const member function just means it\u0027s not allowed to change \u0027val\u0027 to another pointer (which is what we really care about for this class, see line 261). It doesn\u0027t mean the pointee has to remain const. Note that \u0027Value*\u0027 is a pointer to an undefined type. For LLVM, it\u0027s implemented with \u0027llvm::Value*\u0027, and all of the \u0027Builder\u0027 methods take non-const parameters of this type. Likewise for Subzero taking \u0027Operand*\u0027 and \u0027Variable*\u0027 which are almost always non-const.\n\nI suspect that\u0027s because LLVM and Subzero do modify the pointee data even for input parameters, in some cases.\n\nI\u0027m not sure if there\u0027s any value in trying to add const correctness to an undefined type, but I\u0027m open to suggestions for a follow-up change.",
      "parentUuid": "2fcf8c2f_a095b29f",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bd755f9_57080cd3",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 264,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-05-11T19:56:36Z",
      "side": 1,
      "message": "I\u0027m just always wary of const member functions that return modifiable objects. Yes, of course I know that it means the member itself -- the pointer in this case -- will not be modified, but the fact that the thing it points to can be modified means that the expected invariant that const members do not have side effects is broken, which is why we typically return a const pointer/reference from a const member function.\n\nMy guess is that we can probably remove the \u0027const\u0027 on the member function itself, and things would still compile, and be more consistent.",
      "parentUuid": "dec0f188_617b09e0",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "159cab0f_fc70a9e8",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 264,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-05-12T05:17:46Z",
      "side": 1,
      "message": "\u003e but the fact that the thing it points to can be modified\n\nIt\u0027s a pointer to an undefined type. It could have just as well been an integer identifier. But one wouldn\u0027t write \"const int value() const;\" because that doesn\u0027t express that the object it identifies shouldn\u0027t be modified. Likewise I can\u0027t directly call any methods on a Value*, despite the fact that it\u0027s non-const. Functions that take a Value* could modify it, but as long as those modifications are not observable, const correctness is preserved.\n\n\u003e means that the expected invariant that const members do not have side effects is broken\n\nI think we should reason about this in terms of observable constness, not absolute constness. None of the other methods of RValue\u003c\u003e return something different after calling value(). Not even when the Value* is passed to functions that might modify it internally. This is also why the \u0027mutable\u0027 keyword exists, so that one can have internal state which can change while externally things still appear the same, e.g. a cache of sorts. Note that even without mutables or returning an object which could be modified, a const method will still affect things like the CPU caches. So it all depends on what one considers an observable side-effect or not.\n\nAnyway, it really comes down to what one can do with a Value*. It represents an SSA value, so by definition it can\u0027t be assigned a new value or otherwise be manipulated in an observable way. RValue\u003c\u003e has to preserve that behavior by not allowing \u0027val\u0027 to be assigned a new pointer value, but otherwise doesn\u0027t have to worry that the pointee is non-const since there are no functions that violate its SSA nature.\n\n\u003e My guess is that we can probably remove the \u0027const\u0027 on the member function itself, and things would still compile, and be more consistent.\n\nIt breaks quite a few functions that take RValues by const reference. It would also allow our guarantee that \u0027val\u0027 must not be modified, to be broken.",
      "parentUuid": "9bd755f9_57080cd3",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f860a9de_75442d72",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 278,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-05-11T15:27:19Z",
      "side": 1,
      "message": "I wonder if we should just call this function \u0027value\u0027 rather than \u0027rvalue\u0027. Is it important or significant to the caller that we\u0027re getting an r-value? It would make Argument consistent with LValue and RValue. In fact, we might want to derive Argument from RValue in the future so that we can pass them directly to functions that accept a RValue, and having the function named \u0027value\u0027 would mean having less to change (though I know there aren\u0027t many calls to this function).",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3bc8ead6_7cd83f28",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 278,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-05-11T19:42:36Z",
      "side": 1,
      "message": "I think it\u0027s important since, unlike C, we can\u0027t assign new values to an Argument\u003c\u003e.\n\nNote that RValue::value() returns a Value*, not a type-safe RValue\u003c\u003e like this method. So I think it\u0027s useful to make that distinction. LValue doesn\u0027t have a value() method, but a loadValue() one, which also makes an important distinction since, at least logically, one always has to load from its address to obtain the stored value.\n\nI\u0027m not sure there\u0027s much value in allowing Argument\u003c\u003e to be passed directly to functions that take RValues. Note that we can only obtain them from function.Arg\u003c0\u003e() methods, so they\u0027re nameless and the current setup encourages to immediately assign them to named lvalues. After that you never have to use the nameless ones again.",
      "parentUuid": "f860a9de_75442d72",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "92fa38e4_0181a979",
        "filename": "src/Reactor/Reactor.hpp",
        "patchSetId": 9
      },
      "lineNbr": 278,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-05-11T19:56:36Z",
      "side": 1,
      "message": "Fair enough.",
      "parentUuid": "3bc8ead6_7cd83f28",
      "revId": "3447333d674f709a1bd3720cc38255a2ac8cff36",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}