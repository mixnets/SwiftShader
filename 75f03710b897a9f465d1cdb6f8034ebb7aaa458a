{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9cf1d46f_758e673e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9669
      },
      "writtenOn": "2021-01-15T16:07:07Z",
      "side": 1,
      "message": "Note that this change is based off a temp one that allows me to check for memory leaks while ignoring any from Reactor.",
      "revId": "75f03710b897a9f465d1cdb6f8034ebb7aaa458a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a10641e9_d770ceae",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5005
      },
      "writtenOn": "2021-01-15T19:40:37Z",
      "side": 1,
      "message": "Thanks for creating this change. In my humble opinion it illustrates that trying to wrap Vulkan\u0027s C API into thin RAII objects creates quite a bit of dissonance though. While it helps in some areas, things like unique/shared/weak ownership/references are clearly not dealt with by vulkan.hpp in the same rigorous manner as C++11\u0027s smart pointers. Also keep in mind that when writing tests we reference the spec a lot, and so it\u0027s helpful to stick as close to the C calls mentioned by the spec as possible to avoid confusion. FWIW, many tutorials are also written against the C API.\n\nAs I mentioned at b/152889428#comment4, having abstractions like the Image class also reduce the practical benefit we get from partially relying on vulkan.hpp for resource management. Splitting the responsibilities between our code and theirs increases confusion, and I think that also rules out using the RAII objects only in some parts as it would be even more confusing. Again, pool allocated and resettable objects also add to the confusion of ownership and lifetime. It\u0027s a complex matter when reading the spec, but at least it tells the complete story instead of having this largely undocumented C++ wrapper behavior.\n\nI\u0027m also not enamoured with seeing \"Unique\" everywhere. It increases the difference in nomenclature between the spec\u0027s C types, and thee C++ wrappers. \"Unique\" as part of the class names (instead of part of smart pointers) also can be confused for being singletons.\n\nThe biggest advantage of this is the avoidance of leaks, but as I\u0027ve also mentioned earlier I\u0027m not overly concerned about that due to great tooling infrastructure. Keeping a minimal amount of behind-the-scenes magic between the test code and the C API that we\u0027re ultimately trying to test seems more important.",
      "revId": "75f03710b897a9f465d1cdb6f8034ebb7aaa458a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7340186b_22dfa678",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9669
      },
      "writtenOn": "2021-01-15T21:01:02Z",
      "side": 1,
      "message": "Thank you for the feedback. I understand your points, and will go ahead and abandon this change. I will share some of my own opinions here, though:\n\nI think it\u0027s valuable knowing this data member represents the owner, while the regular handle types (vk::Device) represent non-owner/weak references. I also find it helpful that create functions with the Unique suffix only exist for types that must be destroyed as it helps understand the design of Vulkan. It effectively documents the lifetime policy in code without needing to refer to documentation.\n\nAbout having abstractions like the Image class reducing the benefit of these wrappers, I know what you mean, but don\u0027t fully agree. Indeed, I would venture that it helps me understand the meaning of these wrappers even more. For instance, if I see that the wrapper has Unique handle types, then I know it\u0027s an ownership type, and must be treated as such. If the wrapper does not have Unique handle types, then it\u0027s a weak proxy, and its lifetime can be temporary, for instance.\n\nThe \"Unique\" in the name of the type doesn\u0027t bother me, and in fact, is a common pattern (e.g. using UniqueFoo \u003d std::unique_ptr\u003cFoo\u003e). Also, \"unique\" types are a well known C++ concept since C++11, so I don\u0027t think it\u0027s really that confusing. At least the API is consistent (types start with Unique, create functions end with Unique).\n\nI agree with your last point; that it\u0027s mainly useful for avoiding memory leaks. Of course, this is something we do all the time in C++, and feels quite natural. But Vulkan is a C API, and we implement said API, so I understand that we don\u0027t want to hide it behind wrappers. Simply put: it\u0027s useful to be able to put a breakpoint on a destroy function in our tests.",
      "parentUuid": "a10641e9_d770ceae",
      "revId": "75f03710b897a9f465d1cdb6f8034ebb7aaa458a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0714057_eef24f84",
        "filename": "tests/VulkanBenchmarks/VulkanBenchmarks.cpp",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 9669
      },
      "writtenOn": "2021-01-15T16:07:07Z",
      "side": 1,
      "message": "Ignore this, I have this locally because the temp parent change sets us to use C++17, which enables \"nodiscard\" attributes in vulkan.hpp.",
      "revId": "75f03710b897a9f465d1cdb6f8034ebb7aaa458a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec60f417_b4b12559",
        "filename": "tests/VulkanBenchmarks/VulkanBenchmarks.cpp",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 5005
      },
      "writtenOn": "2021-01-15T19:40:37Z",
      "side": 1,
      "message": "Actually let\u0027s pull this into a separate change, to be C++17 ready, together with other changes for cl/351957376.\n\nI believe vulkan.hpp by default adds [[nodiscard]] to ensure applications check for errors. It\u0027s a debatable topic, but graphics applications generally can\u0027t gracefully recover from an unexpected result. Also, for benchmarks like this we want to keep overhead to a minimum. Unexpected results are also going to be extremely rare due to not having to deal with multiple driver implementations (assuming this remains SwiftShader-specific code).\n\nSo I definitely think we can keep this. It also simply preserves the previous behavior, and we should be able to relatively easily change our minds on this later, while in the short term it\u0027s un unnecessary feature/distraction.",
      "parentUuid": "c0714057_eef24f84",
      "revId": "75f03710b897a9f465d1cdb6f8034ebb7aaa458a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa59632e_e4a2a647",
        "filename": "tests/VulkanBenchmarks/VulkanBenchmarks.cpp",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 9669
      },
      "writtenOn": "2021-01-15T21:01:02Z",
      "side": 1,
      "message": "Sure thing, I\u0027ll make this as part of a separate change. I agree that we don\u0027t need to be checking the result in our tests, but it makes sense for applications.",
      "parentUuid": "ec60f417_b4b12559",
      "revId": "75f03710b897a9f465d1cdb6f8034ebb7aaa458a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66459282_18a2fe88",
        "filename": "tests/VulkanBenchmarks/VulkanBenchmarks.cpp",
        "patchSetId": 1
      },
      "lineNbr": 221,
      "author": {
        "id": 9669
      },
      "writtenOn": "2021-01-15T16:07:07Z",
      "side": 1,
      "message": "The fact that this is the only UniqueDevice member shows us that this class is the owner of the device, while vk::Device members in other classes are weak handles. Sadly, the concept of shared/weak doesn\u0027t exist in vulkan.hpp, so we don\u0027t get the safety benefits, but we do get a clearer understanding of ownership.",
      "revId": "75f03710b897a9f465d1cdb6f8034ebb7aaa458a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f377c74_425d0dbd",
        "filename": "tests/VulkanBenchmarks/VulkanBenchmarks.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1187,
      "author": {
        "id": 9669
      },
      "writtenOn": "2021-01-15T16:07:07Z",
      "side": 1,
      "message": "You can see here that I reordered types in creation order so that destruction order is correct. I quite like this.",
      "revId": "75f03710b897a9f465d1cdb6f8034ebb7aaa458a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    }
  ]
}