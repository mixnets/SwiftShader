{
  "comments": [
    {
      "key": {
        "uuid": "b5df7d80_277b0b42",
        "filename": "src/Pipeline/SpirvShaderImage.cpp",
        "patchSetId": 3
      },
      "lineNbr": 573,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-06-17T15:24:37Z",
      "side": 1,
      "message": "you\u0027re going to overflow here in 32 bit builds",
      "range": {
        "startLine": 573,
        "startChar": 8,
        "endLine": 573,
        "endChar": 28
      },
      "revId": "33dccae31935c99e5eeb2fcc4cc6cbe65d4a185b",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0816f79_3287973f",
        "filename": "src/Pipeline/SpirvShaderImage.cpp",
        "patchSetId": 3
      },
      "lineNbr": 573,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-06-17T17:55:19Z",
      "side": 1,
      "message": "No, basePtr has 0 offsets, that\u0027s why it\u0027s called the base pointer. See https://swiftshader-review.googlesource.com/c/SwiftShader/+/45091/3/src/Pipeline/SpirvShaderImage.cpp#642 and other call sites. Anyway, we can make this clearer and more explicit by using an rr::Pointer instead of a SIMD::Pointer for it and constructing the SIMD::Pointer from the base and offsets here.",
      "parentUuid": "b5df7d80_277b0b42",
      "range": {
        "startLine": 573,
        "startChar": 8,
        "endLine": 573,
        "endChar": 28
      },
      "revId": "33dccae31935c99e5eeb2fcc4cc6cbe65d4a185b",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c46886d4_f2428bff",
        "filename": "src/Pipeline/SpirvShaderImage.cpp",
        "patchSetId": 3
      },
      "lineNbr": 573,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-06-17T18:38:19Z",
      "side": 1,
      "message": "It has 0 offsets, but it\u0027s not at address 0. Any basePtr with an address past 0x80000000 will overflow.",
      "parentUuid": "d0816f79_3287973f",
      "range": {
        "startLine": 573,
        "startChar": 8,
        "endLine": 573,
        "endChar": 28
      },
      "revId": "33dccae31935c99e5eeb2fcc4cc6cbe65d4a185b",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7bb73ff2_8007b4c3",
        "filename": "src/Pipeline/SpirvShaderImage.cpp",
        "patchSetId": 3
      },
      "lineNbr": 573,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-06-18T04:28:17Z",
      "side": 1,
      "message": "Please see the new Patchset. The base pointer and the offsets are separate, and the latter are bounds checked before the actual load/store operations, so there\u0027s never any overflow.",
      "parentUuid": "c46886d4_f2428bff",
      "range": {
        "startLine": 573,
        "startChar": 8,
        "endLine": 573,
        "endChar": 28
      },
      "revId": "33dccae31935c99e5eeb2fcc4cc6cbe65d4a185b",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4083d5b7_aec89605",
        "filename": "src/Pipeline/SpirvShaderImage.cpp",
        "patchSetId": 3
      },
      "lineNbr": 573,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-06-18T13:31:45Z",
      "side": 1,
      "message": "Ok, this makes more sense, the operator+ adding to dynamicOffsets rather than basePtr was confusing.",
      "parentUuid": "7bb73ff2_8007b4c3",
      "range": {
        "startLine": 573,
        "startChar": 8,
        "endLine": 573,
        "endChar": 28
      },
      "revId": "33dccae31935c99e5eeb2fcc4cc6cbe65d4a185b",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}