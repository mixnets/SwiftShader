{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ae772e94_6606805d",
        "filename": "src/Reactor/EmulatedIntrinsics.cpp",
        "patchSetId": 3
      },
      "lineNbr": 67,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-01T04:07:10Z",
      "side": 1,
      "message": "Isn\u0027t Call() more expensive then doing an actual multiplication and addition? Is the precision difference really worth doing this? How would this extra precision be requested by the user?",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 67,
        "endChar": 85
      },
      "revId": "695998893e7a15fbf3017ad8b4d27360e936fecd",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "881fb321_d475e46d",
        "filename": "src/Reactor/EmulatedIntrinsics.cpp",
        "patchSetId": 3
      },
      "lineNbr": 67,
      "author": {
        "id": 5005
      },
      "writtenOn": "2022-02-01T04:28:59Z",
      "side": 1,
      "message": "This is for implementing FMA, which must perform a fused multiply-add, i.e. without intermediate rounding. If FMA instructions are not available, it has to be emulated, which cannot be done with a separate multiplication and addition since rounding happens on the intermediate result. The fmaf() function provides this emulated implementation. It is obviously slow, but that\u0027s why fmaIsFast() exists to avoid it.",
      "parentUuid": "ae772e94_6606805d",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 67,
        "endChar": 85
      },
      "revId": "695998893e7a15fbf3017ad8b4d27360e936fecd",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92a1779a_aed4e301",
        "filename": "src/Reactor/EmulatedIntrinsics.cpp",
        "patchSetId": 3
      },
      "lineNbr": 67,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-01T14:24:11Z",
      "side": 1,
      "message": "What I meant was: should there be some way for us to only use FMA in a certain scenario (like if highp is requested) and revert to faster math for medp or lowp, even if something would generate a strict FMA in a shader.",
      "parentUuid": "881fb321_d475e46d",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 67,
        "endChar": 85
      },
      "revId": "695998893e7a15fbf3017ad8b4d27360e936fecd",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1bc99325_b64988fc",
        "filename": "src/Reactor/EmulatedIntrinsics.cpp",
        "patchSetId": 3
      },
      "lineNbr": 67,
      "author": {
        "id": 5005
      },
      "writtenOn": "2022-02-01T16:04:05Z",
      "side": 1,
      "message": "I\u0027ve made an attempt at clarifying the design at b/214591655#comment3. Basically if you have a multiplication and addition that are \"allowed\" to be fused, but  it\u0027s not necessary, use rr::MulAdd(). If you must have a fused operation in a certain algorithm, use rr:FMA(), and fmaIsFast() can be used to fall back to an alternative code path if we have an algorithm that is faster than using fma() function calls and still correct.\n\nNote that Vulkan never demands FMA. Not even for its SPIR-V fma instruction.",
      "parentUuid": "92a1779a_aed4e301",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 67,
        "endChar": 85
      },
      "revId": "695998893e7a15fbf3017ad8b4d27360e936fecd",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18dd5921_944fc0c8",
        "filename": "src/Reactor/EmulatedIntrinsics.cpp",
        "patchSetId": 3
      },
      "lineNbr": 67,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-02T13:27:51Z",
      "side": 1,
      "message": "My only question would be, then:\nIs there any real world scenario where we\u0027d want to use rr:FMA()? In what context would we use this?",
      "parentUuid": "1bc99325_b64988fc",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 67,
        "endChar": 85
      },
      "revId": "695998893e7a15fbf3017ad8b4d27360e936fecd",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "420637f2_220f6d5b",
        "filename": "src/Reactor/EmulatedIntrinsics.cpp",
        "patchSetId": 3
      },
      "lineNbr": 67,
      "author": {
        "id": 5005
      },
      "writtenOn": "2022-02-02T14:34:25Z",
      "side": 1,
      "message": "The main practical use case is an implementation of a transcendental function that uses a polynomial of order N which only produces sufficiently precise results when using FMA operations. When FMA is not available it may require a polynomial of order N+1 or other adjustments.\n\nIt also helps testability that it always returns a consistent result, unlike MulAdd().",
      "parentUuid": "18dd5921_944fc0c8",
      "range": {
        "startLine": 64,
        "startChar": 0,
        "endLine": 67,
        "endChar": 85
      },
      "revId": "695998893e7a15fbf3017ad8b4d27360e936fecd",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    }
  ]
}