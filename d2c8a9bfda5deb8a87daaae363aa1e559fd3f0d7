{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "994f5c12_1d8524ed",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-12-03T02:30:28Z",
      "side": 1,
      "message": "Is this really making tests run 1% faster or is this some noise?",
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "18ee414e_d0bf264e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-03T21:42:30Z",
      "side": 1,
      "message": "Good finds, but it doesn\u0027t look like this addresses any leaks, and only affects start time (which is nice)! I think there are more elegant ways to achieve the startup time benefit for each of these (while also keeping the benefit of not seeing allocations/deallocations happen on dlopen/dlclose):",
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "378b760b_b0c6bd39",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-03T21:42:30Z",
      "side": 1,
      "message": "Looks legit! I checked several previous runs and they all take 26m40+",
      "parentUuid": "994f5c12_1d8524ed",
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bd64d6f7_215c11de",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-12-04T14:54:48Z",
      "side": 1,
      "message": "Here are my thoughts on this change:\n\n- Replacing globals with functions returning a static singleton doesn\u0027t necessarily solve leaks. Indeed, the lazily contructed object will not be freed, and leak sanitizer will probably still report it as a leak. Furthermore, as Nicolas already pointed out in one of his comments, static instances are guaranteed thread-safe since C++11, which typically means we have to pay at least atomic-access cost, if not mutex-based in the worst case.\n\n- WRT replacing global std::vectors with C-style arrays, I would suggest using std::array\u003c\u003e instead of C-style arrays. There is extra runtime cost, they can be used in algorithms, and we get bounds checking in debug builds.\n",
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "79937b41_d968726b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-12-04T14:57:10Z",
      "side": 1,
      "message": "Oh, I wanted to add:\n* I don\u0027t think we should blindly replace globals with functions without proof that it fixes a reported leak. Keep in mind that it may be nearly impossible for us to guarantee no global leaks because of third-party dependencies. In the end, this may be a lost cause. Furthermore, it would surprise me that LeakSanitizer would be unable to discern global static allocations in general, as this would mean it would report leaks in almost every shared object that\u0027s loaded. We probably have a real global leak - something that isn\u0027t feed when the DLL is unloaded.",
      "parentUuid": "bd64d6f7_215c11de",
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e27108b4_38988cab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-12-04T15:16:16Z",
      "side": 1,
      "message": "\u003e ... There is extra runtime cost ...\n\nUgh, I wish I could edit comments posted. Anyway, I meant: \"There is NO extra runtime cost\" to using std::array.",
      "parentUuid": "79937b41_d968726b",
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a05f32c3_f58ff49c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-12-04T22:18:45Z",
      "side": 1,
      "message": "For clarity, I\u0027m not doing any of these changes to remove leaks, I was doing these changes locally to reduce the scope of where the leaks can be found.\n\nWhy use functions then? Because I can find them with LSAN. I can\u0027t find globals, but if the leak comes memory allocated during a function call, even from static variables, LSAN will point straight to it, so, in that regard, removing globals helps with debugging leaks and getting significant stack traces.",
      "parentUuid": "e27108b4_38988cab",
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b954b61f_49101b77",
        "filename": "src/Device/BC_Decoder.cpp",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-03T21:42:30Z",
      "side": 1,
      "message": "I think this could remain static data by replacing the std::vector with a C array. While half of the modes are illegal so this would waste some space, that can be gained back by replacing most of the int types in the above structures by char (as well as making it the underlying type of the enums).\n\nSean, can you look into doing that as a separate change?",
      "range": {
        "startLine": 740,
        "startChar": 0,
        "endLine": 742,
        "endChar": 55
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f4d61b5_37bd7145",
        "filename": "src/Device/BC_Decoder.cpp",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-03T21:49:04Z",
      "side": 1,
      "message": "https://issuetracker.google.com/174782098",
      "parentUuid": "b954b61f_49101b77",
      "range": {
        "startLine": 740,
        "startChar": 0,
        "endLine": 742,
        "endChar": 55
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4dcfbd0c_469a52d9",
        "filename": "src/Device/BC_Decoder.cpp",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-12-03T23:08:52Z",
      "side": 1,
      "message": "After what I just saw in terms of leak debugging and (potential) performance gain, I\u0027m starting to think seldom used data tied to specific features that aren\u0027t used most of the time should almost always be dynamically allocated only once we know we need it. There\u0027s no point in going through static initialization of global variables if we have a good chance of not using it. A static variable inside a function is a simple way of achieving this.\n\nI\u0027m no expert on this subject, though. Do you think that the (potential) performance issue here is entirely related to the use of std::vector as a global static variable? Aren\u0027t we winning anything by not allocating anything if we don\u0027t need the feature? What I\u0027m wondering is the comparison between:\n1) having a global static const array, which most likely resides entirely in the data section of the application\n2) having a local static const array, like here, where its data probably also resides in the data section, but is potentially smaller",
      "parentUuid": "1f4d61b5_37bd7145",
      "range": {
        "startLine": 740,
        "startChar": 0,
        "endLine": 742,
        "endChar": 55
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce59b59d_1a86fcec",
        "filename": "src/Device/BC_Decoder.cpp",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-04T07:06:25Z",
      "side": 1,
      "message": "Oh, certainly your approach has major benefits. I\u0027m just arguing that we can go a step further and try to make the data constexpr. In that case there\u0027s no overhead from dynamic allocations and copying the data, whether it is used at runtime or not. There would also be no point in putting it behind a function call, which adds some overhead of its own (especially since local static data requires a mutex), and it also makes things less elegant in my opinion.\n\nConsidering that this code didn\u0027t leak anything to begin with, I think we have time to go straight for the better solution.",
      "parentUuid": "4dcfbd0c_469a52d9",
      "range": {
        "startLine": 740,
        "startChar": 0,
        "endLine": 742,
        "endChar": 55
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb34d71f_37ad6247",
        "filename": "src/Device/BC_Decoder.cpp",
        "patchSetId": 1
      },
      "lineNbr": 956,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-03T21:42:30Z",
      "side": 1,
      "message": "I think this can be eliminated. There\u0027s always first a Mode, then several EP*, and then a Partition. So just lift the Mode and Partition handling out of the loop.\n\nIf blockDescs[] was split up into info for Mode, EP*s, and Partition, we wouldn\u0027t even need the Mode and Partition enums, it seems?",
      "range": {
        "startLine": 956,
        "startChar": 3,
        "endLine": 956,
        "endChar": 20
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8314f5f4_45f8c9c6",
        "filename": "src/Vulkan/VkGetProcAddress.cpp",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-03T21:42:30Z",
      "side": 1,
      "message": "I\u0027d rather make these C arrays, and have vk::Instance and vk::Device place them in member maps during construction.",
      "range": {
        "startLine": 36,
        "startChar": 1,
        "endLine": 36,
        "endChar": 65
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3874869_4d1bee07",
        "filename": "src/Vulkan/VkGetProcAddress.cpp",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-12-03T23:08:52Z",
      "side": 1,
      "message": "I can do that for the ones below, but this one specifically is global and doesn\u0027t belong to Instances or Devices.\nAlso, putting them in member maps could potentially cause duplication of these, if we have multiple instances/devices.",
      "parentUuid": "8314f5f4_45f8c9c6",
      "range": {
        "startLine": 36,
        "startChar": 1,
        "endLine": 36,
        "endChar": 65
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c6a2735_ffeaf926",
        "filename": "src/Vulkan/VkGetProcAddress.cpp",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-04T07:06:25Z",
      "side": 1,
      "message": "\u003e I can do that for the ones below, but this one specifically is global and doesn\u0027t belong to Instances or Devices.\n\nRight, for this one, which will always be tiny, a global C array would be fine and searching it linearly is probably even faster than an unordered_map.\n\n\u003e Also, putting them in member maps could potentially cause duplication of these, if we have multiple instances/devices.\n\nTrue, but that\u0027s probably a negligible concern given that most applications create just one instance and one device. Note that in the future we\u0027ll want the set of exposed extensions to be run-time controllable for fuzzer test purposes, which means we need a non-static array anyway. By only storing the pointers to the strings, and sorting them by content, we can can both have minimal storage needs and fast lookup through bsearch().",
      "parentUuid": "f3874869_4d1bee07",
      "range": {
        "startLine": 36,
        "startChar": 1,
        "endLine": 36,
        "endChar": 65
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0b0f3bd_870bc0b0",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 1
      },
      "lineNbr": 94,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-03T21:42:30Z",
      "side": 1,
      "message": "\u003ccinttypes\u003e",
      "range": {
        "startLine": 94,
        "startChar": 9,
        "endLine": 94,
        "endChar": 21
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "01c757ae_da4fb15e",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 1
      },
      "lineNbr": 94,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-12-03T23:08:52Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "d0b0f3bd_870bc0b0",
      "range": {
        "startLine": 94,
        "startChar": 9,
        "endLine": 94,
        "endChar": 21
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91066cf5_cd98db80",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1331,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-03T21:42:30Z",
      "side": 1,
      "message": "Although \u003ccinttypes\u003e is an official C++11 header, I have a vague recollection that these things are not always universally supported. That said, it\u0027s 2020, so we might be fine.\n\nLGTM, but please split this into a separate patch.",
      "range": {
        "startLine": 1331,
        "startChar": 131,
        "endLine": 1331,
        "endChar": 138
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bd1d73dd_b6bcecee",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1331,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-12-03T23:08:52Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "91066cf5_cd98db80",
      "range": {
        "startLine": 1331,
        "startChar": 131,
        "endLine": 1331,
        "endChar": 138
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "893d0c89_5afd0f6e",
        "filename": "src/WSI/XcbSurfaceKHR.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-03T21:42:30Z",
      "side": 1,
      "message": "I think this class can be left as-is. It didn\u0027t have any member fields, and no (explicit) constructor/destructor. It only does the loading of the exports on the first operator-\u003e usage.",
      "range": {
        "startLine": 54,
        "startChar": 6,
        "endLine": 54,
        "endChar": 12
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b587de0_251dd3ee",
        "filename": "src/WSI/XcbSurfaceKHR.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-12-03T23:08:52Z",
      "side": 1,
      "message": "In the previous version, \"exports\", the static variable in loadExports(), was potentially not released.\nI still don\u0027t think this is done right currently, if we go through the loadLibrary path, but this may need to be fixed (I don\u0027t know if there\u0027s any need to unload the library). Anyway, I can remove this from this cl, this is a different issue.",
      "parentUuid": "893d0c89_5afd0f6e",
      "range": {
        "startLine": 54,
        "startChar": 6,
        "endLine": 54,
        "endChar": 12
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fff5e08b_6245a39b",
        "filename": "src/WSI/XcbSurfaceKHR.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-04T07:06:25Z",
      "side": 1,
      "message": "I don\u0027t see why exports (and the LibXcbExports instance it holds) wouldn\u0027t be deleted in the old version. Can you elaborate on why you think that\u0027s the case?",
      "parentUuid": "6b587de0_251dd3ee",
      "range": {
        "startLine": 54,
        "startChar": 6,
        "endLine": 54,
        "endChar": 12
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71f8c8ff_39a1817c",
        "filename": "src/WSI/XcbSurfaceKHR.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-12-04T14:00:28Z",
      "side": 1,
      "message": "I didn\u0027t mean the exports object itself, I meant that I didn\u0027t know if a cleanup was necessary after calling loadLibrary (maybe some unloadLibrary function, similarly to dlopen/dlclose, although that\u0027s probably a bad example, as dlclose isn\u0027t forced to cleanup everything)",
      "parentUuid": "fff5e08b_6245a39b",
      "range": {
        "startLine": 54,
        "startChar": 6,
        "endLine": 54,
        "endChar": 12
      },
      "revId": "d2c8a9bfda5deb8a87daaae363aa1e559fd3f0d7",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    }
  ]
}