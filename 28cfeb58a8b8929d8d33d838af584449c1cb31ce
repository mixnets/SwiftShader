{
  "comments": [
    {
      "key": {
        "uuid": "ca5809ca_41d73a90",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:05:51Z",
      "side": 1,
      "message": "Since it\u0027s a singleton (at least currently), can\u0027t we just fetch it as a global where we need it instead of passing it around as an argument?",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c95aa6e_43e78c69",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "I\u0027m not entirely convinced.\n\nYes, it currently has a single instance in libVulkan.cpp, but this may not always be the case.\n\nPerhaps we will want to enable / disable the debugger functionality based on a vkCreateInstance() extension property?\nPerhaps we will want to have a different vk::dbg::Context implementation for ensuring spirv-opt passes behave as expected, by writing out each line transition state to a file, but without the overhead of a DAP connection?\nPerhaps we want to write unit / integration tests that verifies the expected vk::dbg::Context calls are made using a mock vk::dbg::Context?\n\nA couple of these examples are more than hypothetical, but I haven\u0027t formalized a proper plan to present to you yet. That and singletons being a global with a fancy name, and you know how much I love them. ðŸ˜Š",
      "parentUuid": "ca5809ca_41d73a90",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b63bdb4_71596628",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-17T21:54:37Z",
      "side": 1,
      "message": "I think each of those examples can still be handled by having a global singleton, and just making it return a different type of debugger implementation.\n\nThe way I conceptualize this is that the debugger is something \u0027out there\u0027 that we communicate with, either a socket or a process, or a file. Almost like logging. You wouldn\u0027t want to have to pass around the debug log handle to every function where you have something to log. That gets configured globally, and can also take different forms. It\u0027s also often possible to log to different files by specifying some enum at the log call site. In other words using a singleton doesn\u0027t have to mean you have only one implementation available.\n\nThat said, I\u0027m totally open to reconsidering this if and when the singleton doesn\u0027t work out. It\u0027s much more convincing that we need something, when we need something. ðŸ˜‰",
      "parentUuid": "1c95aa6e_43e78c69",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6297e14_046bc701",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-18T13:44:42Z",
      "side": 1,
      "message": "\u003e I think each of those examples can still be handled by having a global singleton, and just making it return a different type of debugger implementation.\n\nHow can a singleton handle a debugger property for vkCreateInstance()? This is a per-instance attribute.\n\n\u003e It\u0027s also often possible to log to different files by specifying some enum at the log call site. In other words using a singleton doesn\u0027t have to mean you have only one implementation available\n\nIf you are proposing that a debugger-enabled flag is passed down to the vk instances, then what\u0027s the benefit of passing flags down and using a singleton than just simply passing down the debugger context directly?\n\n\u003e The way I conceptualize this is that the debugger is something \u0027out there\u0027 that we communicate with, either a socket or a process, or a file.\n\nNot my argument, but I whole heartily agree:\nhttp://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-open-or-stdout-\n\n\u003e Almost like logging\n\nhttp://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-debug-logging-\n\nExcept it isn\u0027t like logging. Logging is publicly stateless. The vk::dbg::Context structure is a big blob of state, and you\u0027re proposing that we access this big blob of state via a global variable.\n\nIf you haven\u0027t already, please see go/singletons.\n\nFor the sake of passing down an additional variable into the constructor of a class, you\u0027re breaking encapsulation, muddying project dependencies, making thread safety more complex, complicating initialization and destruction points, making concurrent testing impossible, and so on.\n\nIt\u0027s just a bad pattern, one that is frowned on at Google.",
      "parentUuid": "7b63bdb4_71596628",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72795c40_a6533933",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-18T21:08:04Z",
      "side": 1,
      "message": "First things first: these are all excellent discussion points worth debating, but I feel like it would be more productive to first focus on the minimal viable product, then gather feedback on feature requests, and then only for the ones with sufficient impact determine how to fit them in exactly.\n\n\u003e How can a singleton handle a debugger property for vkCreateInstance()? This is a per-instance attribute.\n\nSorry, I missed the per-instance expectation part. I\u0027m not sure what the value of that would be though. The vast majority of applications have just one instance. For those that have multiple, I\u0027m not sure they would have a strong need for selectively enabling debugging. Also note that not enabling an extension doesn\u0027t typically disable them. The Vulkan ICD is not required to perform validation, so unless you have a validation layer for it that somehow checks you\u0027re not debugging an instance that didn\u0027t specify the extension, it\u0027s essentially always enabled if your implementation supports it. I\u0027m not saying we should encourage abusing that property of the extension mechanism. I\u0027m just pointing out that this is hard to enforce and maybe a VK extension is not the right approach if/when we really need this. Also FWIW note that we\u0027ll most likely eventually split our back-end into a separate process. In large part for security, but it also enables e.g. exposing separate \u0027physical devices\u0027 for separate CPU sockets. It might make some sense to debug those separately. But it could be a singleton in each process. In any case, I think it\u0027s very premature to prepare for a per-instance debugger feature.\n\n\u003e http://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-open-or-stdout-\n\nIt appears this is only talking about native C\u0027s open(). There are plenty of examples of sandboxes which provide an open()-like function which provide the security he seeks in his problem statement, yet still provide singleton access to a portion of the filesystem. No need to pass some \u0027Directory\u0027 argument around everywhere (I\u0027m not saying this can\u0027t be sensible in many cases, even within a sandbox, I\u0027m just saying it can also be perfectly acceptable not to require it if it fits design requirements).\n\n\u003e http://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-debug-logging-\n\u003e Except it isn\u0027t like logging. Logging is publicly stateless.\n\nI did say \"almost\". ðŸ˜Ž Note this site argues that \"As for stdout, the same thing applies.\", so I\u0027m not sure the distinction matters that much. Also note the argument that \"Another theoretical justification for debug logging says that the debug log function is really just a no-op that happens to be observed by the debugger.  When no debugger is running, the function does nothing.  Debugging in general obviously breaks the entire object-capability model, but it is also obviously a privileged operation.\" This is still valid if it\u0027s not stateless.\n\n\u003e If you haven\u0027t already, please see go/singletons.\n\nI appreciate the link, but rest assured this is not the first time I\u0027ve heard of \"singletons considered harmful\". It\u0027s an excellent first rule to avoid them, since they almost always result in real-world bad consequences, but not always. Even object-oriented-security.org states \"Singletons are almost always bad design\", meaning there can be cases where it\u0027s good design.\n\nThis is not some kind of white raven argument. Reactor is a great example. It would be absolutely disastrous for its usability if we had to provide the JIT context explicitly at various points, instead of using a global.\n\nNote that https://testing.googleblog.com/2008/08/root-cause-of-singletons.html (linked from go/singletons) states that \"The moment you traverse a global variable your API lies about its true dependencies\". But the debugger won\u0027t be a dependency in that sense. The Vulkan API behavior must remain the same with or without debugger. Their paragraph about logging comes to the same conclusion.",
      "parentUuid": "e6297e14_046bc701",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "658939a1_8c96f9d0",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:05:51Z",
      "side": 1,
      "message": "This adds about 32 bytes to every command buffer when we\u0027re not debugging. This might add up for some game engines that create a command buffer for each object and/or overallocate their pools. There\u0027s some constructor/destructor overhead too. All minor, I\u0027m sure, but slippery slope and all that.\n\nSince you\u0027re already guarding the actual logic with #ifdef ENABLE_VK_DEBUGGER this could probably be eliminated when no building with debugger support as well.",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "596736b3_f65ec2da",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "Fair point. It\u0027s easy to forget that a single shared_ptr is a pair of pointers.\n\nI can wrap this with a preprocessor flag for now, but I am hoping that I can get this into a state where it can be used as part of a standard-config build (i.e. default ENABLE_VK_DEBUGGER to true)\n\nWhat are your thoughts about pointer-indirecting the Debug structure (std::unique_ptr\u003cDebug\u003e)? This adds a runtime heap allocation overhead for when this is actually enabled and used, but who cares.\nThis would lower the general memory cost to an additional 8 bytes when runtime-disabled but still compiled in.\nIs that acceptable?",
      "parentUuid": "658939a1_8c96f9d0",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b4efb8c_a81411fb",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T11:18:43Z",
      "side": 1,
      "message": "Wrapped in #ifdef ENABLE_VK_DEBUGGER, and also used std::unique_ptr\u003c\u003e to reduce the overhead to a single pointer.",
      "parentUuid": "596736b3_f65ec2da",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fbc189bb_c4dfb37f",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:17:38Z",
      "side": 1,
      "message": "nit: Consider consistently calling this the debugger context. Similar arguments to why we went with ENABLE_VK_DEBUGGER instead of ENABLE_VK_DEBUG",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33a30795_7ef0c7b0",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "Sure thing. I think there\u0027s still a few places that use the old \u0027debug\u0027 name before your suggestion to rename to \u0027debugger\u0027.\nI\u0027ll see if I can find all of them and do one big rename.",
      "parentUuid": "fbc189bb_c4dfb37f",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38ed327e_e07e20c6",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T11:18:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "33a30795_7ef0c7b0",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}