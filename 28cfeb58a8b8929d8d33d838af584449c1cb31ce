{
  "comments": [
    {
      "key": {
        "uuid": "ca5809ca_41d73a90",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:05:51Z",
      "side": 1,
      "message": "Since it\u0027s a singleton (at least currently), can\u0027t we just fetch it as a global where we need it instead of passing it around as an argument?",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c95aa6e_43e78c69",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "I\u0027m not entirely convinced.\n\nYes, it currently has a single instance in libVulkan.cpp, but this may not always be the case.\n\nPerhaps we will want to enable / disable the debugger functionality based on a vkCreateInstance() extension property?\nPerhaps we will want to have a different vk::dbg::Context implementation for ensuring spirv-opt passes behave as expected, by writing out each line transition state to a file, but without the overhead of a DAP connection?\nPerhaps we want to write unit / integration tests that verifies the expected vk::dbg::Context calls are made using a mock vk::dbg::Context?\n\nA couple of these examples are more than hypothetical, but I haven\u0027t formalized a proper plan to present to you yet. That and singletons being a global with a fancy name, and you know how much I love them. ðŸ˜Š",
      "parentUuid": "ca5809ca_41d73a90",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b63bdb4_71596628",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-17T21:54:37Z",
      "side": 1,
      "message": "I think each of those examples can still be handled by having a global singleton, and just making it return a different type of debugger implementation.\n\nThe way I conceptualize this is that the debugger is something \u0027out there\u0027 that we communicate with, either a socket or a process, or a file. Almost like logging. You wouldn\u0027t want to have to pass around the debug log handle to every function where you have something to log. That gets configured globally, and can also take different forms. It\u0027s also often possible to log to different files by specifying some enum at the log call site. In other words using a singleton doesn\u0027t have to mean you have only one implementation available.\n\nThat said, I\u0027m totally open to reconsidering this if and when the singleton doesn\u0027t work out. It\u0027s much more convincing that we need something, when we need something. ðŸ˜‰",
      "parentUuid": "1c95aa6e_43e78c69",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6297e14_046bc701",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-18T13:44:42Z",
      "side": 1,
      "message": "\u003e I think each of those examples can still be handled by having a global singleton, and just making it return a different type of debugger implementation.\n\nHow can a singleton handle a debugger property for vkCreateInstance()? This is a per-instance attribute.\n\n\u003e It\u0027s also often possible to log to different files by specifying some enum at the log call site. In other words using a singleton doesn\u0027t have to mean you have only one implementation available\n\nIf you are proposing that a debugger-enabled flag is passed down to the vk instances, then what\u0027s the benefit of passing flags down and using a singleton than just simply passing down the debugger context directly?\n\n\u003e The way I conceptualize this is that the debugger is something \u0027out there\u0027 that we communicate with, either a socket or a process, or a file.\n\nNot my argument, but I whole heartily agree:\nhttp://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-open-or-stdout-\n\n\u003e Almost like logging\n\nhttp://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-debug-logging-\n\nExcept it isn\u0027t like logging. Logging is publicly stateless. The vk::dbg::Context structure is a big blob of state, and you\u0027re proposing that we access this big blob of state via a global variable.\n\nIf you haven\u0027t already, please see go/singletons.\n\nFor the sake of passing down an additional variable into the constructor of a class, you\u0027re breaking encapsulation, muddying project dependencies, making thread safety more complex, complicating initialization and destruction points, making concurrent testing impossible, and so on.\n\nIt\u0027s just a bad pattern, one that is frowned on at Google.",
      "parentUuid": "7b63bdb4_71596628",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72795c40_a6533933",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-18T21:08:04Z",
      "side": 1,
      "message": "First things first: these are all excellent discussion points worth debating, but I feel like it would be more productive to first focus on the minimal viable product, then gather feedback on feature requests, and then only for the ones with sufficient impact determine how to fit them in exactly.\n\n\u003e How can a singleton handle a debugger property for vkCreateInstance()? This is a per-instance attribute.\n\nSorry, I missed the per-instance expectation part. I\u0027m not sure what the value of that would be though. The vast majority of applications have just one instance. For those that have multiple, I\u0027m not sure they would have a strong need for selectively enabling debugging. Also note that not enabling an extension doesn\u0027t typically disable them. The Vulkan ICD is not required to perform validation, so unless you have a validation layer for it that somehow checks you\u0027re not debugging an instance that didn\u0027t specify the extension, it\u0027s essentially always enabled if your implementation supports it. I\u0027m not saying we should encourage abusing that property of the extension mechanism. I\u0027m just pointing out that this is hard to enforce and maybe a VK extension is not the right approach if/when we really need this. Also FWIW note that we\u0027ll most likely eventually split our back-end into a separate process. In large part for security, but it also enables e.g. exposing separate \u0027physical devices\u0027 for separate CPU sockets. It might make some sense to debug those separately. But it could be a singleton in each process. In any case, I think it\u0027s very premature to prepare for a per-instance debugger feature.\n\n\u003e http://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-open-or-stdout-\n\nIt appears this is only talking about native C\u0027s open(). There are plenty of examples of sandboxes which provide an open()-like function which provide the security he seeks in his problem statement, yet still provide singleton access to a portion of the filesystem. No need to pass some \u0027Directory\u0027 argument around everywhere (I\u0027m not saying this can\u0027t be sensible in many cases, even within a sandbox, I\u0027m just saying it can also be perfectly acceptable not to require it if it fits design requirements).\n\n\u003e http://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-debug-logging-\n\u003e Except it isn\u0027t like logging. Logging is publicly stateless.\n\nI did say \"almost\". ðŸ˜Ž Note this site argues that \"As for stdout, the same thing applies.\", so I\u0027m not sure the distinction matters that much. Also note the argument that \"Another theoretical justification for debug logging says that the debug log function is really just a no-op that happens to be observed by the debugger.  When no debugger is running, the function does nothing.  Debugging in general obviously breaks the entire object-capability model, but it is also obviously a privileged operation.\" This is still valid if it\u0027s not stateless.\n\n\u003e If you haven\u0027t already, please see go/singletons.\n\nI appreciate the link, but rest assured this is not the first time I\u0027ve heard of \"singletons considered harmful\". It\u0027s an excellent first rule to avoid them, since they almost always result in real-world bad consequences, but not always. Even object-oriented-security.org states \"Singletons are almost always bad design\", meaning there can be cases where it\u0027s good design.\n\nThis is not some kind of white raven argument. Reactor is a great example. It would be absolutely disastrous for its usability if we had to provide the JIT context explicitly at various points, instead of using a global.\n\nNote that https://testing.googleblog.com/2008/08/root-cause-of-singletons.html (linked from go/singletons) states that \"The moment you traverse a global variable your API lies about its true dependencies\". But the debugger won\u0027t be a dependency in that sense. The Vulkan API behavior must remain the same with or without debugger. Their paragraph about logging comes to the same conclusion.",
      "parentUuid": "e6297e14_046bc701",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3256c14_ce43e5e5",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-19T02:03:20Z",
      "side": 1,
      "message": "\u003e First things first: these are all excellent discussion points worth debating, but I feel like it would be more productive to first focus on the minimal viable product, then gather feedback on feature requests, and then only for the ones with sufficient impact determine how to fit them in exactly.\n\nI\u0027m not trying to push more than the MVP. I\u0027m trying to point out that you\u0027re encouraging that I change code that does what it needs to do, following standard idiomatic Google C++ patterns, for personal opinions that have numerous known real-world issues and are clearly discouraged by C++ language experts at Google. The only argument I have heard so far for making these changes is that it would remove an additional parameter to a couple of class constructors.\nFor immediate goals: I want to write tests for the debugger - both unit tests and those for testing spirv-tools. Using global state for this will make it impossible to perform concurrent, single-process parallel testing. That in its own should be justification for not wanting to use singletons and global state.\n\n\u003e Sorry, I missed the per-instance expectation part. I\u0027m not sure what the value of that would be though.\n\nI was thinking something akin to the `D3D11_CREATE_DEVICE_DEBUGGABLE` flag. Sometimes environment variables are just not as convenient as per-instance, runtime flags.\n\n\u003e The Vulkan ICD is not required to perform validation, so unless you have a validation layer for it that somehow checks you\u0027re not debugging an instance that didn\u0027t specify the extension, it\u0027s essentially always enabled if your implementation supports it.\n\nI\u0027m not entirely sure what you\u0027re getting at here. Are you suggesting we always enable the debugger? This doesn\u0027t sound ideal.\n\n\u003e The vast majority of applications have just one instance. For those that have multiple, I\u0027m not sure they would have a strong need for selectively enabling debugging.\n\nMaybe, maybe not. Looking at the bigger picture, I\u0027m trying to figure out how this might work as a Vulkan feature or extension. The root object in the Vulkan API is the VkDevice, so I don\u0027t see any reason here to make things more global-state than the existing highest level Vulkan API object, unless there\u0027s a really compelling argument to do so.\n\n\u003e Also FWIW note that we\u0027ll most likely eventually split our back-end into a separate process. In large part for security, but it also enables e.g. exposing separate \u0027physical devices\u0027 for separate CPU sockets. It might make some sense to debug those separately. But it could be a singleton in each process. \n\nThis seems your argument here is that \"global state is fine because one day there will only be one VkDevice instance per process\". Until that\u0027s true, how about we don\u0027t depend on global state unless it is absolutely necessary?\n\n\u003e In any case, I think it\u0027s very premature to prepare for a per-instance debugger feature.\n\nI don\u0027t think that non-costly, idiomatic design patterns that also cater for future needs is premature. Again, we\u0027re actively discussing here changing from a global stateless design (with exception of single instance currently created in libVulkan.cpp and passed down to child systems) to one that entirely depends on a single, globally referenced variable. I think you need to have a really strong argument for making this change. I haven\u0027t heard one yet.\n\n\u003e http://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-open-or-stdout-\n\u003e It appears this is only talking about native C\u0027s open(). There are plenty of examples of sandboxes which provide an open()-like function which provide the security he seeks in his problem statement, yet still provide singleton access to a portion of the filesystem. No need to pass some \u0027Directory\u0027 argument around everywhere (I\u0027m not saying this can\u0027t be sensible in many cases, even within a sandbox, I\u0027m just saying it can also be perfectly acceptable not to require it if it fits design requirements).\n\nI think you\u0027re missing a large part of the argument here. The author isn\u0027t suggesting simply passing a \u0027Directory\u0027 parameter around everywhere, they\u0027re proposing passing a generic file-system interface to the systems that need a file accesses API. That\u0027s a big difference. The former is just a parameter to the standard file system interface, the latter is an abstraction that can be implemented in any number of different ways, including mock implementations that can test for system behaviour. This is the basic principle behind gmock testing - https://github.com/google/googletest/tree/master/googlemock.\n\n\u003e \u003e http://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-debug-logging-\n\u003e \u003e \"Another theoretical justification for debug logging says that the debug log function is really just a no-op that happens to be observed by the debugger.  When no debugger is running, the function does nothing.  Debugging in general obviously breaks the entire object-capability model, but it is also obviously a privileged operation.\"\n\n\u003e This is still valid if it\u0027s not stateless.\n\nThat\u0027s a jump in logic I don\u0027t follow. The vk::dbg::Context is a bag of state, with a whole lot of API to query and modify it. The whole argument put forward by this author is about how logging is a purely push-state API; as in log calls can be made, but nothing can be queried.  This is simply not true of a singleton debugger context.\n\n\u003e  Even object-oriented-security.org states \"Singletons are almost always bad design\", meaning there can be cases where it\u0027s good design.\n\nI find your statement\u0027s logic here to be dubious.\n\n  !(a \u003e b) !\u003d (b \u003e a)\n\ni.e. \"almost always bad design\" does not equate to meaning there are cases where it\u0027s sometimes good design.\n\n\u003e Reactor is a great example. It would be absolutely disastrous for its usability if we had to provide the JIT context explicitly at various points, instead of using a global.\n\nPlease don\u0027t get me wrong - I really like much of the Reactor API, but I had major beef with its use of global state for reasons I\u0027ve tried to make clear before. Reactor required a big-fat-mutex over the whole internal Reactor state, and this was a prime example of why global state is a Bad Ideaâ„¢.\nAfter significant reworking, the LLVM Reactor backend is now at least thread local, and is so safe to call on concurrent threads (https://swiftshader-review.googlesource.com/c/SwiftShader/+/33484 proves this). I did this work so that we can finally do concurrent compilation, which was previously impossible due to its carefree use of globals.\nI get that parameter passing can be fugly, and for the Reactor API, I entirely agree that expecting context to be passed into each reactor function is impractical. But that\u0027s not what we\u0027re discussing here.\nWe\u0027re debating a couple of parameters to infrequently called object constructors, for objects that can quite happily be built and executed concurrently, as exposed by the Vulkan API.\n\n\u003e Note that https://testing.googleblog.com/2008/08/root-cause-of-singletons.html (linked from go/singletons) states that \"The moment you traverse a global variable your API lies about its true dependencies\". But the debugger won\u0027t be a dependency in that sense.\n\nWhy not? The Vulkan device interacts with the debugger context, both for state reads and writes. How is that not a true dependency \"in that sense\"?\n\n\u003e The Vulkan API behavior must remain the same with or without debugger.\n\nThe Vulkan API might remain the same, but that says nothing about the debugger state across multiple devices.\nI just don\u0027t buy the argument that a vk::dbg::Context singleton is equivalent to the logging pattern, which is deemed by these articles as the only-just-about-acceptable form of singleton.\n\nPassing the debugger context down is not adding a huge readability burden on the codebase, and is not is it drastically increasing memory consumption. Pushing for global state is a big anti-pattern and will bite us when it comes to testing and if/when we want a separate debugger context per device.\n\nPlease, let\u0027s not do this.",
      "parentUuid": "72795c40_a6533933",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e09a59a_4fd22a2a",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-19T13:09:37Z",
      "side": 1,
      "message": "One more point: I was chatting with pbaiget yesterday who\u0027s starting to do planning for next year. He wanted to talk to me about how SwiftShader\u0027s debugging was coming along as they\u0027re interested in using this.\n\nGAPID creates a replay device (process) that is long lived. Replays are performed on the device by re-creating vulkan device instances, doing the graphics operation, and then destroying the instance.\nUnless the shader debugging functionality is actively in use, then the vkDevice instances created have no need for debugging. It was my intention that we can pass to vkCreateDevice() the information that:\na) Debugging for this particular instance is required\nb) How the application should connect to the debugger - whether it is a port, file handle, or perhaps a straight up C callback API.\n\nAttempting to share the Vulkan context across devices is undesirable in this situation. You\u0027d just be making it harder to identify particular shader invocations and threads.",
      "parentUuid": "a3256c14_ce43e5e5",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "658939a1_8c96f9d0",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:05:51Z",
      "side": 1,
      "message": "This adds about 32 bytes to every command buffer when we\u0027re not debugging. This might add up for some game engines that create a command buffer for each object and/or overallocate their pools. There\u0027s some constructor/destructor overhead too. All minor, I\u0027m sure, but slippery slope and all that.\n\nSince you\u0027re already guarding the actual logic with #ifdef ENABLE_VK_DEBUGGER this could probably be eliminated when no building with debugger support as well.",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "596736b3_f65ec2da",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "Fair point. It\u0027s easy to forget that a single shared_ptr is a pair of pointers.\n\nI can wrap this with a preprocessor flag for now, but I am hoping that I can get this into a state where it can be used as part of a standard-config build (i.e. default ENABLE_VK_DEBUGGER to true)\n\nWhat are your thoughts about pointer-indirecting the Debug structure (std::unique_ptr\u003cDebug\u003e)? This adds a runtime heap allocation overhead for when this is actually enabled and used, but who cares.\nThis would lower the general memory cost to an additional 8 bytes when runtime-disabled but still compiled in.\nIs that acceptable?",
      "parentUuid": "658939a1_8c96f9d0",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b4efb8c_a81411fb",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T11:18:43Z",
      "side": 1,
      "message": "Wrapped in #ifdef ENABLE_VK_DEBUGGER, and also used std::unique_ptr\u003c\u003e to reduce the overhead to a single pointer.",
      "parentUuid": "596736b3_f65ec2da",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fbc189bb_c4dfb37f",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:17:38Z",
      "side": 1,
      "message": "nit: Consider consistently calling this the debugger context. Similar arguments to why we went with ENABLE_VK_DEBUGGER instead of ENABLE_VK_DEBUG",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33a30795_7ef0c7b0",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "Sure thing. I think there\u0027s still a few places that use the old \u0027debug\u0027 name before your suggestion to rename to \u0027debugger\u0027.\nI\u0027ll see if I can find all of them and do one big rename.",
      "parentUuid": "fbc189bb_c4dfb37f",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38ed327e_e07e20c6",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T11:18:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "33a30795_7ef0c7b0",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}