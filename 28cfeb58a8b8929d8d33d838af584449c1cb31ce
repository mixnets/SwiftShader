{
  "comments": [
    {
      "key": {
        "uuid": "ca5809ca_41d73a90",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:05:51Z",
      "side": 1,
      "message": "Since it\u0027s a singleton (at least currently), can\u0027t we just fetch it as a global where we need it instead of passing it around as an argument?",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c95aa6e_43e78c69",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "I\u0027m not entirely convinced.\n\nYes, it currently has a single instance in libVulkan.cpp, but this may not always be the case.\n\nPerhaps we will want to enable / disable the debugger functionality based on a vkCreateInstance() extension property?\nPerhaps we will want to have a different vk::dbg::Context implementation for ensuring spirv-opt passes behave as expected, by writing out each line transition state to a file, but without the overhead of a DAP connection?\nPerhaps we want to write unit / integration tests that verifies the expected vk::dbg::Context calls are made using a mock vk::dbg::Context?\n\nA couple of these examples are more than hypothetical, but I haven\u0027t formalized a proper plan to present to you yet. That and singletons being a global with a fancy name, and you know how much I love them. ðŸ˜Š",
      "parentUuid": "ca5809ca_41d73a90",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b63bdb4_71596628",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-17T21:54:37Z",
      "side": 1,
      "message": "I think each of those examples can still be handled by having a global singleton, and just making it return a different type of debugger implementation.\n\nThe way I conceptualize this is that the debugger is something \u0027out there\u0027 that we communicate with, either a socket or a process, or a file. Almost like logging. You wouldn\u0027t want to have to pass around the debug log handle to every function where you have something to log. That gets configured globally, and can also take different forms. It\u0027s also often possible to log to different files by specifying some enum at the log call site. In other words using a singleton doesn\u0027t have to mean you have only one implementation available.\n\nThat said, I\u0027m totally open to reconsidering this if and when the singleton doesn\u0027t work out. It\u0027s much more convincing that we need something, when we need something. ðŸ˜‰",
      "parentUuid": "1c95aa6e_43e78c69",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6297e14_046bc701",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-18T13:44:42Z",
      "side": 1,
      "message": "\u003e I think each of those examples can still be handled by having a global singleton, and just making it return a different type of debugger implementation.\n\nHow can a singleton handle a debugger property for vkCreateInstance()? This is a per-instance attribute.\n\n\u003e It\u0027s also often possible to log to different files by specifying some enum at the log call site. In other words using a singleton doesn\u0027t have to mean you have only one implementation available\n\nIf you are proposing that a debugger-enabled flag is passed down to the vk instances, then what\u0027s the benefit of passing flags down and using a singleton than just simply passing down the debugger context directly?\n\n\u003e The way I conceptualize this is that the debugger is something \u0027out there\u0027 that we communicate with, either a socket or a process, or a file.\n\nNot my argument, but I whole heartily agree:\nhttp://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-open-or-stdout-\n\n\u003e Almost like logging\n\nhttp://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-debug-logging-\n\nExcept it isn\u0027t like logging. Logging is publicly stateless. The vk::dbg::Context structure is a big blob of state, and you\u0027re proposing that we access this big blob of state via a global variable.\n\nIf you haven\u0027t already, please see go/singletons.\n\nFor the sake of passing down an additional variable into the constructor of a class, you\u0027re breaking encapsulation, muddying project dependencies, making thread safety more complex, complicating initialization and destruction points, making concurrent testing impossible, and so on.\n\nIt\u0027s just a bad pattern, one that is frowned on at Google.",
      "parentUuid": "7b63bdb4_71596628",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72795c40_a6533933",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-18T21:08:04Z",
      "side": 1,
      "message": "First things first: these are all excellent discussion points worth debating, but I feel like it would be more productive to first focus on the minimal viable product, then gather feedback on feature requests, and then only for the ones with sufficient impact determine how to fit them in exactly.\n\n\u003e How can a singleton handle a debugger property for vkCreateInstance()? This is a per-instance attribute.\n\nSorry, I missed the per-instance expectation part. I\u0027m not sure what the value of that would be though. The vast majority of applications have just one instance. For those that have multiple, I\u0027m not sure they would have a strong need for selectively enabling debugging. Also note that not enabling an extension doesn\u0027t typically disable them. The Vulkan ICD is not required to perform validation, so unless you have a validation layer for it that somehow checks you\u0027re not debugging an instance that didn\u0027t specify the extension, it\u0027s essentially always enabled if your implementation supports it. I\u0027m not saying we should encourage abusing that property of the extension mechanism. I\u0027m just pointing out that this is hard to enforce and maybe a VK extension is not the right approach if/when we really need this. Also FWIW note that we\u0027ll most likely eventually split our back-end into a separate process. In large part for security, but it also enables e.g. exposing separate \u0027physical devices\u0027 for separate CPU sockets. It might make some sense to debug those separately. But it could be a singleton in each process. In any case, I think it\u0027s very premature to prepare for a per-instance debugger feature.\n\n\u003e http://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-open-or-stdout-\n\nIt appears this is only talking about native C\u0027s open(). There are plenty of examples of sandboxes which provide an open()-like function which provide the security he seeks in his problem statement, yet still provide singleton access to a portion of the filesystem. No need to pass some \u0027Directory\u0027 argument around everywhere (I\u0027m not saying this can\u0027t be sensible in many cases, even within a sandbox, I\u0027m just saying it can also be perfectly acceptable not to require it if it fits design requirements).\n\n\u003e http://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-debug-logging-\n\u003e Except it isn\u0027t like logging. Logging is publicly stateless.\n\nI did say \"almost\". ðŸ˜Ž Note this site argues that \"As for stdout, the same thing applies.\", so I\u0027m not sure the distinction matters that much. Also note the argument that \"Another theoretical justification for debug logging says that the debug log function is really just a no-op that happens to be observed by the debugger.  When no debugger is running, the function does nothing.  Debugging in general obviously breaks the entire object-capability model, but it is also obviously a privileged operation.\" This is still valid if it\u0027s not stateless.\n\n\u003e If you haven\u0027t already, please see go/singletons.\n\nI appreciate the link, but rest assured this is not the first time I\u0027ve heard of \"singletons considered harmful\". It\u0027s an excellent first rule to avoid them, since they almost always result in real-world bad consequences, but not always. Even object-oriented-security.org states \"Singletons are almost always bad design\", meaning there can be cases where it\u0027s good design.\n\nThis is not some kind of white raven argument. Reactor is a great example. It would be absolutely disastrous for its usability if we had to provide the JIT context explicitly at various points, instead of using a global.\n\nNote that https://testing.googleblog.com/2008/08/root-cause-of-singletons.html (linked from go/singletons) states that \"The moment you traverse a global variable your API lies about its true dependencies\". But the debugger won\u0027t be a dependency in that sense. The Vulkan API behavior must remain the same with or without debugger. Their paragraph about logging comes to the same conclusion.",
      "parentUuid": "e6297e14_046bc701",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3256c14_ce43e5e5",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-19T02:03:20Z",
      "side": 1,
      "message": "\u003e First things first: these are all excellent discussion points worth debating, but I feel like it would be more productive to first focus on the minimal viable product, then gather feedback on feature requests, and then only for the ones with sufficient impact determine how to fit them in exactly.\n\nI\u0027m not trying to push more than the MVP. I\u0027m trying to point out that you\u0027re encouraging that I change code that does what it needs to do, following standard idiomatic Google C++ patterns, for personal opinions that have numerous known real-world issues and are clearly discouraged by C++ language experts at Google. The only argument I have heard so far for making these changes is that it would remove an additional parameter to a couple of class constructors.\nFor immediate goals: I want to write tests for the debugger - both unit tests and those for testing spirv-tools. Using global state for this will make it impossible to perform concurrent, single-process parallel testing. That in its own should be justification for not wanting to use singletons and global state.\n\n\u003e Sorry, I missed the per-instance expectation part. I\u0027m not sure what the value of that would be though.\n\nI was thinking something akin to the `D3D11_CREATE_DEVICE_DEBUGGABLE` flag. Sometimes environment variables are just not as convenient as per-instance, runtime flags.\n\n\u003e The Vulkan ICD is not required to perform validation, so unless you have a validation layer for it that somehow checks you\u0027re not debugging an instance that didn\u0027t specify the extension, it\u0027s essentially always enabled if your implementation supports it.\n\nI\u0027m not entirely sure what you\u0027re getting at here. Are you suggesting we always enable the debugger? This doesn\u0027t sound ideal.\n\n\u003e The vast majority of applications have just one instance. For those that have multiple, I\u0027m not sure they would have a strong need for selectively enabling debugging.\n\nMaybe, maybe not. Looking at the bigger picture, I\u0027m trying to figure out how this might work as a Vulkan feature or extension. The root object in the Vulkan API is the VkDevice, so I don\u0027t see any reason here to make things more global-state than the existing highest level Vulkan API object, unless there\u0027s a really compelling argument to do so.\n\n\u003e Also FWIW note that we\u0027ll most likely eventually split our back-end into a separate process. In large part for security, but it also enables e.g. exposing separate \u0027physical devices\u0027 for separate CPU sockets. It might make some sense to debug those separately. But it could be a singleton in each process. \n\nThis seems your argument here is that \"global state is fine because one day there will only be one VkDevice instance per process\". Until that\u0027s true, how about we don\u0027t depend on global state unless it is absolutely necessary?\n\n\u003e In any case, I think it\u0027s very premature to prepare for a per-instance debugger feature.\n\nI don\u0027t think that non-costly, idiomatic design patterns that also cater for future needs is premature. Again, we\u0027re actively discussing here changing from a global stateless design (with exception of single instance currently created in libVulkan.cpp and passed down to child systems) to one that entirely depends on a single, globally referenced variable. I think you need to have a really strong argument for making this change. I haven\u0027t heard one yet.\n\n\u003e http://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-open-or-stdout-\n\u003e It appears this is only talking about native C\u0027s open(). There are plenty of examples of sandboxes which provide an open()-like function which provide the security he seeks in his problem statement, yet still provide singleton access to a portion of the filesystem. No need to pass some \u0027Directory\u0027 argument around everywhere (I\u0027m not saying this can\u0027t be sensible in many cases, even within a sandbox, I\u0027m just saying it can also be perfectly acceptable not to require it if it fits design requirements).\n\nI think you\u0027re missing a large part of the argument here. The author isn\u0027t suggesting simply passing a \u0027Directory\u0027 parameter around everywhere, they\u0027re proposing passing a generic file-system interface to the systems that need a file accesses API. That\u0027s a big difference. The former is just a parameter to the standard file system interface, the latter is an abstraction that can be implemented in any number of different ways, including mock implementations that can test for system behaviour. This is the basic principle behind gmock testing - https://github.com/google/googletest/tree/master/googlemock.\n\n\u003e \u003e http://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-debug-logging-\n\u003e \u003e \"Another theoretical justification for debug logging says that the debug log function is really just a no-op that happens to be observed by the debugger.  When no debugger is running, the function does nothing.  Debugging in general obviously breaks the entire object-capability model, but it is also obviously a privileged operation.\"\n\n\u003e This is still valid if it\u0027s not stateless.\n\nThat\u0027s a jump in logic I don\u0027t follow. The vk::dbg::Context is a bag of state, with a whole lot of API to query and modify it. The whole argument put forward by this author is about how logging is a purely push-state API; as in log calls can be made, but nothing can be queried.  This is simply not true of a singleton debugger context.\n\n\u003e  Even object-oriented-security.org states \"Singletons are almost always bad design\", meaning there can be cases where it\u0027s good design.\n\nI find your statement\u0027s logic here to be dubious.\n\n  !(a \u003e b) !\u003d (b \u003e a)\n\ni.e. \"almost always bad design\" does not equate to meaning there are cases where it\u0027s sometimes good design.\n\n\u003e Reactor is a great example. It would be absolutely disastrous for its usability if we had to provide the JIT context explicitly at various points, instead of using a global.\n\nPlease don\u0027t get me wrong - I really like much of the Reactor API, but I had major beef with its use of global state for reasons I\u0027ve tried to make clear before. Reactor required a big-fat-mutex over the whole internal Reactor state, and this was a prime example of why global state is a Bad Ideaâ„¢.\nAfter significant reworking, the LLVM Reactor backend is now at least thread local, and is so safe to call on concurrent threads (https://swiftshader-review.googlesource.com/c/SwiftShader/+/33484 proves this). I did this work so that we can finally do concurrent compilation, which was previously impossible due to its carefree use of globals.\nI get that parameter passing can be fugly, and for the Reactor API, I entirely agree that expecting context to be passed into each reactor function is impractical. But that\u0027s not what we\u0027re discussing here.\nWe\u0027re debating a couple of parameters to infrequently called object constructors, for objects that can quite happily be built and executed concurrently, as exposed by the Vulkan API.\n\n\u003e Note that https://testing.googleblog.com/2008/08/root-cause-of-singletons.html (linked from go/singletons) states that \"The moment you traverse a global variable your API lies about its true dependencies\". But the debugger won\u0027t be a dependency in that sense.\n\nWhy not? The Vulkan device interacts with the debugger context, both for state reads and writes. How is that not a true dependency \"in that sense\"?\n\n\u003e The Vulkan API behavior must remain the same with or without debugger.\n\nThe Vulkan API might remain the same, but that says nothing about the debugger state across multiple devices.\nI just don\u0027t buy the argument that a vk::dbg::Context singleton is equivalent to the logging pattern, which is deemed by these articles as the only-just-about-acceptable form of singleton.\n\nPassing the debugger context down is not adding a huge readability burden on the codebase, and is not is it drastically increasing memory consumption. Pushing for global state is a big anti-pattern and will bite us when it comes to testing and if/when we want a separate debugger context per device.\n\nPlease, let\u0027s not do this.",
      "parentUuid": "72795c40_a6533933",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e09a59a_4fd22a2a",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-19T13:09:37Z",
      "side": 1,
      "message": "One more point: I was chatting with pbaiget yesterday who\u0027s starting to do planning for next year. He wanted to talk to me about how SwiftShader\u0027s debugging was coming along as they\u0027re interested in using this.\n\nGAPID creates a replay device (process) that is long lived. Replays are performed on the device by re-creating vulkan device instances, doing the graphics operation, and then destroying the instance.\nUnless the shader debugging functionality is actively in use, then the vkDevice instances created have no need for debugging. It was my intention that we can pass to vkCreateDevice() the information that:\na) Debugging for this particular instance is required\nb) How the application should connect to the debugger - whether it is a port, file handle, or perhaps a straight up C callback API.\n\nAttempting to share the Vulkan context across devices is undesirable in this situation. You\u0027d just be making it harder to identify particular shader invocations and threads.",
      "parentUuid": "a3256c14_ce43e5e5",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b737692_a131555a",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-21T07:04:56Z",
      "side": 1,
      "message": "\u003e ...for personal opinions that have numerous known real-world issues and are clearly discouraged by C++ language experts at Google.\n\nMy opinion is rooted in genuine design decision concerns. But before I get back to those: I believe we\u0027re all C++ language experts here. Many a Good Practice has trade-offs that can in specific cases result in having a better outcome by avoiding it. Lots of great OOD patterns have a negative impact on e.g. performance due to cache coherency consequences and pointer chasing (i.e. expert topics). I\u0027m obviously not claiming that\u0027s the issue with this CL. I\u0027m only using it as an example to justify why I\u0027d rather discuss this on technical merits, instead of blindly trusting on generalized rules from experts who haven\u0027t explicitly considered this arguably atypical case.\n\n\u003e The only argument I have heard so far for making these changes is that it would remove an additional parameter to a couple of class constructors.\n\nYes! Well, not just a couple (https://swiftshader-review.googlesource.com/38914). I can\u0027t help but point out that despite your stance towards singletons, this change still introduces one. The parameter plumbing is trivial to add in again if and when it becomes necessary, which as I said early on I\u0027m very open to consider.\n\nThe issue I have with the additional parameter right now is that it is totally non-obvious that a CommandBuffer constructor should take a debugger parameter. Sure, we\u0027re adding debugging to the command buffer in this CL, but out of context this makes little sense. It\u0027s easy for a maintainer years later to make the mistake of constructing a new debugger object and pass that in, or alter it in some way in layers that are just supposed to pass it down. Basically it increases complexity and puts extra responsibility on every developer touching this code.\n\nWhich brings us back to the singleton. It allows to contain that complexity and responsibility to the areas that actually interact with the debugger.\n\nIn that sense I don\u0027t think this is very different from logging. It would be pretty maddening if several constructors of major API object implementations took a parameter related to logging. If we land this CL as-is, it would create a slippery slope where that would suddenly become reasonable to consider. \"This is getting out hand. Now there are two of them!\" - Nute Gunray\n\nAnd the list goes on. The CPUID class is another example of context-like state which one could consider making per-instance or per-device configurable, but which would look out of place as a constructor argument for Vulkan objects, to say the least.\n\n\u003e Using global state for this will make it impossible to perform concurrent, single-process parallel testing.\n\nI\u0027m not sure single-process testing of multiple debugger connections makes much sense to be honest. In any case this well exceeds the MVP requirements and is best kept for a later discussion. I can\u0027t quite conceive why multi-process testing wouldn\u0027t be acceptable. And even if you have a great reason for that, I doubt it\u0027s not something we can reconsider later, especially since this CL still has the singleton and my only concern is the parameter plumbing, which if truly necessary should be straightforward to reintroduce at any point.\n\n\u003e I was thinking something akin to the `D3D11_CREATE_DEVICE_DEBUGGABLE` flag. Sometimes environment variables are just not as convenient as per-instance, runtime flags.\n\nI wasn\u0027t suggesting an environment variable for it. That\u0027s a great example of indisputably bad singleton behavior, in my book. It would cause unexpected slow performance if it was inadvertently enabled.\n\nInstead I think it\u0027s perfectly reasonable for it to affect the whole process. Note \"D3D11_CREATE_DEVICE_DEBUGGABLE - Causes the device and driver to keep information that you can use for shader debugging. The exact impact from this flag will vary from driver to driver.\" The vast majority of apps use a single device, and for those that use multiple I sincerely doubt the developers would expect no impact on the ones that don\u0027t specify this flag.\n\nAt least for the MVP. Once again, I\u0027m open to user-driven changes in design requirements later on.\n\n\u003e Looking at the bigger picture, I\u0027m trying to figure out how this might work as a Vulkan feature or extension. The root object in the Vulkan API is the VkDevice...\n\nFrom the software abstraction point of view, sure, that\u0027s your root object. But underlying to every VkDevice is the VkPhysicalDevice. They represent the card(s) or chip(s) themselves, or virtual instances of those. Obviously most common is to have just one, but even with multiple ones, from a software perspective each of them would be a singleton. And it is exceedingly common for the hardware to have registers that dictate chip-wide behavior. Throughout SwiftShader\u0027s history I\u0027ve encountered many cases where being a \u0027software\u0027 implementation allowed more flexibility, at a performance and/or maintenance cost. To my recollection, implementing such flexibility that goes beyond \u0027hardware\u0027 implementations has never amounted to a real-world benefit. Extensions that were SwiftShader-specific were not put to significant use, and were just a burden to keep around.\n\nSo while I\u0027m delighted that SwiftShader can be used as a proving ground for features that we hope would get adopted by other drivers, I\u0027d strongly caution against over-engineering it to support things that are technically feasible on the CPU but may receive pushback from GPU vendors, either because they can\u0027t support it or because it requires considerable complexity for which they don\u0027t expect to see much return.\n\n\u003e That\u0027s a jump in logic I don\u0027t follow. The vk::dbg::Context is a bag of state, with a whole lot of API to query and modify it. The whole argument put forward by this author is about how logging is a purely push-state API; as in log calls can be made, but nothing can be queried.  This is simply not true of a singleton debugger context.\n\nAbsolutely. I was not trying to generalize conclusions about write-only singletons to read-write ones. But the author provides the arguments for *why* a write-only singleton is benign, and those arguments *can* also apply to a read-write singleton, under certain conditions. Essentially it needs to have no side-effects on the rest of the program.\n\nTo clarify what I mean by the rest of the program, and at the same time give another example of acceptable read-write singleton: Loggers aren\u0027t necessarily write-only. You can execute \u0027logcat -d\u0027 from any Android app. This can be useful to generate reports when something unexpected happens. The app may even reformat it before adding it to the report, but all the data remains within this boundary of logging/reporting related code.\n\nIn the case of the shader debugger, having it be optionally compiled in provides great guarantees that we have a boundary that protects against the pitfalls of singletons. And in fact not passing it around through argument lists would provide further insurance that we\u0027re not accessing it in layers that shouldn\u0027t touch it.\n\n\u003e \u003e \"Singletons are almost always bad design\", meaning there can be cases where it\u0027s good design.\n\n\u003e I find your statement\u0027s logic here to be dubious. \"almost always bad design\" does not equate to meaning there are cases where it\u0027s sometimes good design.\n\nThat\u0027s not what I said. \"there can be cases\", doesn\u0027t mean there are any. I was just pointing out that Kenton didn\u0027t go as far as saying good uses of singletons don\u0027t exist. Then I immediately followed up with the example of Reactor.\n\n\u003e Please don\u0027t get me wrong - I really like much of the Reactor API, but I had major beef with its use of global state for reasons I\u0027ve tried to make clear before. Reactor required a big-fat-mutex over the whole internal Reactor state, and this was a prime example of why global state is a Bad Ideaâ„¢.\n\nNote that LLVM\u0027s JIT wasn\u0027t thread safe for many years, so it was a conscious decision not to put any effort into making Reactor concurrent. Also, the effort to make it thread safe remained the same over the years, so it\u0027s not like that was a bad design decision with costly consequences. And although it\u0027s thread-local now, the state is still a singleton per thread. So I stand by Reactor being an example where the use of singletons is good design.\n\nJust to be clear, I\u0027m aware there\u0027s still risk associated with it. One might start a new Reactor Function before having finalized the previous one, or create Reactor variables outside of a Function scope. If C++ had a feature where one could construct objects that have access to the \u0027this\u0027 pointer at the location they\u0027re created, without explicitly adding it as a constructor argument, that might go a long way toward being able to eliminate the singletons. And I recognize that as a better solution. But until that day, using a singleton is substantially better than the alternative.\n\n\u003e I entirely agree that expecting context to be passed into each reactor function is impractical. But that\u0027s not what we\u0027re discussing here.\n\nI don\u0027t think it\u0027s impractical. Mesa\u0027s llvmpipe uses the bare-bones LLVM JIT interface, passing around the context for every IR instruction being emitted. Less practical than Reactor, for sure, but not impractical. Instead, it\u0027s unnecessary, and adds complexity. It is by design that Reactor requires to work on one function at a time. If a context was used for every instruction being emitted, it would be tempting to e.g. implement shader functions by emitting them as new functions while still working on the shader as a whole. It would be massively confusing which context to use. Likewise one might be tempted to name the context after the function you\u0027re emitting, but this discourages code reuse and needlessly complicates refactoring.\n\nPutting the context in a singleton instead creates a powerful abstraction where you no longer have to think about it much.\n\n\u003e We\u0027re debating a couple of parameters to infrequently called object constructors...\n\nI don\u0027t think it\u0027s a safe assumption it will stay that way. This debugger interface opens up many possibilities beyond shader debugging. Heck, this CL is a great example of exactly that. There\u0027s no telling how many other uses we\u0027ll find for it. Compounding this is that our Vulkan implementation itself will increase in complexity as we add more API features and make major changes to improve performance and security, all of which are likely to increase the number of objects the debugger context would have to be passed through.\n\nIf it\u0027s absolutely necessary that debugging is controlled on a per-device bases (which I\u0027m still not convinced about and which we can still settle later), I suggest passing the device handle to these constructors instead, and where you need the debugger context you retrieve it from the device. This way we\u0027d decouple knowledge about Vulkan objects from knowledge about debugger usage.",
      "parentUuid": "5e09a59a_4fd22a2a",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0cbb06fe_cb5154a3",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-21T15:43:38Z",
      "side": 1,
      "message": "\u003e The issue I have with the additional parameter right now is that it is totally non-obvious that a CommandBuffer constructor should take a debugger parameter.\n\nI assume you meant \u0027why it should take a debugger parameter\u0027. It is totally obvious that it does take one - and that\u0027s a good thing.\nWhen you see a parameter in the constructor you know it is used, either directly or transitively. A global accessed by an internal system makes zero announcements about the dependency. Let\u0027s ignore the transitive dependencies part for now: You want to unit write a test for SpirvShader, how many globals do you need to set first? You really want to go digging though the N .cpp files that make up SpirvShader to answer this? You really want to make sure you restore the global state after each test to ensure you\u0027re not inadvertently affecting tests that get called after this one?\n\n\u003e It\u0027s easy for a maintainer years later to make the mistake of constructing a new debugger object and pass that in\n\nThat\u0027s a documentation problem and I agree we should add some.\n\n\u003e or alter it in some way in layers that are just supposed to pass it down.\n\nAnd a global solves this how? At least by having a dependency chain like this *allows* you to alter things if need be, without the insane chaos that globals cause.\n\n\u003e Basically it increases complexity and puts extra responsibility on every developer touching this code.\n\nThe complexity is exactly the same. We\u0027re just being up front about it.\n\n\u003e Which brings us back to the singleton. It allows to contain that complexity and responsibility to the areas that actually interact with the debugger.\n\nI don\u0027t agree a singleton gives any sort of containment, quite the opposite, and it entirely obfuscates that complexity. It opens the door to anyone and everyone accessing the data, increasing complexity across the entire codebase, and giving no responsibility to any particular system(s).\n\n\u003e To clarify what I mean by the rest of the program, and at the same time give another example of acceptable read-write singleton: Loggers aren\u0027t necessarily write-only. You can execute \u0027logcat -d\u0027 from any Android app. This can be useful to generate reports when something unexpected happens. The app may even reformat it before adding it to the report, but all the data remains within this boundary of logging/reporting related code.\n\nI think you\u0027re stretching the argument a little here. :)\n\nYou could also start reading fixed byte offsets from class pointers to read from protected and private fields, or access the framebuffer and OCR the text on screen, or overwrite the first N instructions of the write functions to spy on the writes, or use some CPU branch misprediction timing hack to read memory, etc, to hack around the inability to pull back data from an API designed to be queryless.\n\nI\u0027ll play along with your example though. I\u0027ve actually worked on a project that did exactly this to create bug reports, and guess what? Most reports were completely useless, as they never contained the logging data that we needed. Other apps would spam logcat so much that all the relevant data had been pushed out the ring buffer. This is just yet another example of issues with global (or in this case whole-system) state. There was just no control over who was writing to the log, so there was no way to ensure that the application we were developing had all its LOG() messages included. The solution? A private logger with its own internal state \u0026 log file.\n\n\u003e In that sense I don\u0027t think this is very different from logging. It would be pretty maddening if several constructors of major API object implementations took a parameter related to logging. If we land this CL as-is, it would create a slippery slope where that would suddenly become reasonable to consider.\n\nI\u0027ve worked on projects where the logger was always passed where needed. It really wasn\u0027t that bad as constructor calls are simply not written that frequently. I certainly wouldn\u0027t have called it maddening.\nI get dependency passing is verbose - but if you end up with constructor parameter list that are crazy long, it is obvious and we can ask the question \"why does this class require so many dependencies?\". Using singletons and globals would just sweep this under the carpet.\n\n\u003e The CPUID class is another example of context-like state which one could consider making per-instance or per-device configurable\n\nAnother class that has particularly dubious use of global state.\nThe old renderer updated a bunch of static CPUID members in Renderer::updateConfiguration(). It was completely non-obvious to me whether this was guaranteed to be non-concurrently written (I suspect it could be concurrently written, but given the whole global-state-read-and-written-in-multiple-internal-methods it was very hard to prove either way).\nFor the marl changes, I tried moving all static member assignments to this class to early initializer in libVulkan.cpp so that we could treat it as immutable. But there\u0027s currently nothing stopping new code playing with the settings mid-execution, leading to data races.\nI also noticed when going near this class that there\u0027s no way to bulk save/restore or put back defaults. If we wanted to write tests for CPUID settings, it is stupidly easy to forget to restore the default settings after you\u0027re done, potentially corrupting the behavior of all other tests that run after it. Global state is just a recipe for bugs.\n\n\u003e ... but which would look out of place as a constructor argument for Vulkan objects, to say the least.\n\nIf those objects were clearly responsible for doing JIT compilation, then I really don\u0027t think it would look out of place. It would be a great big signal to me that these objects constructed JIT compilers, and I\u0027d know exactly where to specify the flags. Now if you think compiler settings on these objects seem out of place, then you could argue that they\u0027re doing too much themselves, and should probably be passed something that does the building and initializing of the compilers (i.e. a factory) that holds its own configuration state, which is the basic premise for the Dependency Injection pattern (https://en.wikipedia.org/wiki/Dependency_injection, go/dependency-injection). This is even more verbose, but also has a bunch of useful characteristics, especially for testing.\nBased on this discussion, I suspect you\u0027d classify full DI as over-engineering, hence why I haven\u0027t proposed it yet (I\u0027d also consider this a step beyond what\u0027s necessary right now, but I have very much liked DI when I\u0027ve used it before).\n\n\u003e Putting the context in a singleton instead creates a powerful abstraction where you no longer have to think about it much.\n\nExcept for when it blows up because you have concurrent writes, out lives some other transitive dependency, makes it impossible to perform concurrent testing, makes it far harder to know when it needs to be constructed before calling some function that references it, and so on.\n\n\u003e I suggest passing the device handle to these constructors instead, and where you need the debugger context you retrieve it from the device. This way we\u0027d decouple knowledge about Vulkan objects from knowledge about debugger usage.\n\nOkay, this is a compromise I\u0027m up for considering, but I do fear this is venturing into the God Object anti-pattern.\nIf we pass the VkDevice down everywhere as it holds a bunch of general purpose state, you\u0027ll still have the \"does function/class/system X make use state of Y\" ambiguity, which can be a nightmare when writing tests - e.g. how much of VkDevice state do I need to set / mock before I can call this function? If function X suddenly starts using a new data member on VkDevice, which existing tests need updating as they make a transitive call to X?\"\n\nThat said, this is still a million times better than grabbing random crap from globals and through const members, can help enforce immutability, so I\u0027m up for this as a compromise. I will make these changes if you\u0027re also okay with this.\n\nI\u0027m sure we\u0027re not the only people on the team who have opinions on this topic. Any other thoughts and past experiences from the team?",
      "parentUuid": "2b737692_a131555a",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "658939a1_8c96f9d0",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:05:51Z",
      "side": 1,
      "message": "This adds about 32 bytes to every command buffer when we\u0027re not debugging. This might add up for some game engines that create a command buffer for each object and/or overallocate their pools. There\u0027s some constructor/destructor overhead too. All minor, I\u0027m sure, but slippery slope and all that.\n\nSince you\u0027re already guarding the actual logic with #ifdef ENABLE_VK_DEBUGGER this could probably be eliminated when no building with debugger support as well.",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "596736b3_f65ec2da",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "Fair point. It\u0027s easy to forget that a single shared_ptr is a pair of pointers.\n\nI can wrap this with a preprocessor flag for now, but I am hoping that I can get this into a state where it can be used as part of a standard-config build (i.e. default ENABLE_VK_DEBUGGER to true)\n\nWhat are your thoughts about pointer-indirecting the Debug structure (std::unique_ptr\u003cDebug\u003e)? This adds a runtime heap allocation overhead for when this is actually enabled and used, but who cares.\nThis would lower the general memory cost to an additional 8 bytes when runtime-disabled but still compiled in.\nIs that acceptable?",
      "parentUuid": "658939a1_8c96f9d0",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b4efb8c_a81411fb",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T11:18:43Z",
      "side": 1,
      "message": "Wrapped in #ifdef ENABLE_VK_DEBUGGER, and also used std::unique_ptr\u003c\u003e to reduce the overhead to a single pointer.",
      "parentUuid": "596736b3_f65ec2da",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fbc189bb_c4dfb37f",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:17:38Z",
      "side": 1,
      "message": "nit: Consider consistently calling this the debugger context. Similar arguments to why we went with ENABLE_VK_DEBUGGER instead of ENABLE_VK_DEBUG",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33a30795_7ef0c7b0",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "Sure thing. I think there\u0027s still a few places that use the old \u0027debug\u0027 name before your suggestion to rename to \u0027debugger\u0027.\nI\u0027ll see if I can find all of them and do one big rename.",
      "parentUuid": "fbc189bb_c4dfb37f",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38ed327e_e07e20c6",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T11:18:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "33a30795_7ef0c7b0",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}