{
  "comments": [
    {
      "key": {
        "uuid": "ca5809ca_41d73a90",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:05:51Z",
      "side": 1,
      "message": "Since it\u0027s a singleton (at least currently), can\u0027t we just fetch it as a global where we need it instead of passing it around as an argument?",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c95aa6e_43e78c69",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "I\u0027m not entirely convinced.\n\nYes, it currently has a single instance in libVulkan.cpp, but this may not always be the case.\n\nPerhaps we will want to enable / disable the debugger functionality based on a vkCreateInstance() extension property?\nPerhaps we will want to have a different vk::dbg::Context implementation for ensuring spirv-opt passes behave as expected, by writing out each line transition state to a file, but without the overhead of a DAP connection?\nPerhaps we want to write unit / integration tests that verifies the expected vk::dbg::Context calls are made using a mock vk::dbg::Context?\n\nA couple of these examples are more than hypothetical, but I haven\u0027t formalized a proper plan to present to you yet. That and singletons being a global with a fancy name, and you know how much I love them. ðŸ˜Š",
      "parentUuid": "ca5809ca_41d73a90",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b63bdb4_71596628",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-17T21:54:37Z",
      "side": 1,
      "message": "I think each of those examples can still be handled by having a global singleton, and just making it return a different type of debugger implementation.\n\nThe way I conceptualize this is that the debugger is something \u0027out there\u0027 that we communicate with, either a socket or a process, or a file. Almost like logging. You wouldn\u0027t want to have to pass around the debug log handle to every function where you have something to log. That gets configured globally, and can also take different forms. It\u0027s also often possible to log to different files by specifying some enum at the log call site. In other words using a singleton doesn\u0027t have to mean you have only one implementation available.\n\nThat said, I\u0027m totally open to reconsidering this if and when the singleton doesn\u0027t work out. It\u0027s much more convincing that we need something, when we need something. ðŸ˜‰",
      "parentUuid": "1c95aa6e_43e78c69",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6297e14_046bc701",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 57,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-18T13:44:42Z",
      "side": 1,
      "message": "\u003e I think each of those examples can still be handled by having a global singleton, and just making it return a different type of debugger implementation.\n\nHow can a singleton handle a debugger property for vkCreateInstance()? This is a per-instance attribute.\n\n\u003e It\u0027s also often possible to log to different files by specifying some enum at the log call site. In other words using a singleton doesn\u0027t have to mean you have only one implementation available\n\nIf you are proposing that a debugger-enabled flag is passed down to the vk instances, then what\u0027s the benefit of passing flags down and using a singleton than just simply passing down the debugger context directly?\n\n\u003e The way I conceptualize this is that the debugger is something \u0027out there\u0027 that we communicate with, either a socket or a process, or a file.\n\nNot my argument, but I whole heartily agree:\nhttp://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-open-or-stdout-\n\n\u003e Almost like logging\n\nhttp://www.object-oriented-security.org/lets-argue/singletons#TOC-What-about-debug-logging-\n\nExcept it isn\u0027t like logging. Logging is publicly stateless. The vk::dbg::Context structure is a big blob of state, and you\u0027re proposing that we access this big blob of state via a global variable.\n\nIf you haven\u0027t already, please see go/singletons.\n\nFor the sake of passing down an additional variable into the constructor of a class, you\u0027re breaking encapsulation, muddying project dependencies, making thread safety more complex, complicating initialization and destruction points, making concurrent testing impossible, and so on.\n\nIt\u0027s just a bad pattern, one that is frowned on at Google.",
      "parentUuid": "7b63bdb4_71596628",
      "range": {
        "startLine": 57,
        "startChar": 42,
        "endLine": 57,
        "endChar": 91
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "658939a1_8c96f9d0",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:05:51Z",
      "side": 1,
      "message": "This adds about 32 bytes to every command buffer when we\u0027re not debugging. This might add up for some game engines that create a command buffer for each object and/or overallocate their pools. There\u0027s some constructor/destructor overhead too. All minor, I\u0027m sure, but slippery slope and all that.\n\nSince you\u0027re already guarding the actual logic with #ifdef ENABLE_VK_DEBUGGER this could probably be eliminated when no building with debugger support as well.",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "596736b3_f65ec2da",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "Fair point. It\u0027s easy to forget that a single shared_ptr is a pair of pointers.\n\nI can wrap this with a preprocessor flag for now, but I am hoping that I can get this into a state where it can be used as part of a standard-config build (i.e. default ENABLE_VK_DEBUGGER to true)\n\nWhat are your thoughts about pointer-indirecting the Debug structure (std::unique_ptr\u003cDebug\u003e)? This adds a runtime heap allocation overhead for when this is actually enabled and used, but who cares.\nThis would lower the general memory cost to an additional 8 bytes when runtime-disabled but still compiled in.\nIs that acceptable?",
      "parentUuid": "658939a1_8c96f9d0",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b4efb8c_a81411fb",
        "filename": "src/Vulkan/VkCommandBuffer.hpp",
        "patchSetId": 18
      },
      "lineNbr": 213,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T11:18:43Z",
      "side": 1,
      "message": "Wrapped in #ifdef ENABLE_VK_DEBUGGER, and also used std::unique_ptr\u003c\u003e to reduce the overhead to a single pointer.",
      "parentUuid": "596736b3_f65ec2da",
      "range": {
        "startLine": 213,
        "startChar": 1,
        "endLine": 213,
        "endChar": 11
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fbc189bb_c4dfb37f",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-12-11T18:17:38Z",
      "side": 1,
      "message": "nit: Consider consistently calling this the debugger context. Similar arguments to why we went with ENABLE_VK_DEBUGGER instead of ENABLE_VK_DEBUG",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33a30795_7ef0c7b0",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T00:06:10Z",
      "side": 1,
      "message": "Sure thing. I think there\u0027s still a few places that use the old \u0027debug\u0027 name before your suggestion to rename to \u0027debugger\u0027.\nI\u0027ll see if I can find all of them and do one big rename.",
      "parentUuid": "fbc189bb_c4dfb37f",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38ed327e_e07e20c6",
        "filename": "src/Vulkan/libVulkan.cpp",
        "patchSetId": 18
      },
      "lineNbr": 157,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-12-12T11:18:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "33a30795_7ef0c7b0",
      "range": {
        "startLine": 157,
        "startChar": 37,
        "endLine": 157,
        "endChar": 49
      },
      "revId": "28cfeb58a8b8929d8d33d838af584449c1cb31ce",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}