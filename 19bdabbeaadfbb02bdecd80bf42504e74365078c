{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "b2f0faf1_a1768faa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 15
      },
      "lineNbr": 0,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-17T17:26:59Z",
      "side": 1,
      "message": "Nice! Looks like a net inprovement with great readability to me.",
      "revId": "19bdabbeaadfbb02bdecd80bf42504e74365078c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8e09ff58_a39d7c81",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 15
      },
      "lineNbr": 0,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-17T18:44:45Z",
      "side": 1,
      "message": "Awesome! Thanks for the code review :). I was very happy to learn we could restrict this even further to StackSizeLimit!",
      "parentUuid": "b2f0faf1_a1768faa",
      "revId": "19bdabbeaadfbb02bdecd80bf42504e74365078c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f216aeb8_6d326bc9",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 15
      },
      "lineNbr": 840,
      "author": {
        "id": 46365
      },
      "writtenOn": "2023-07-17T16:32:41Z",
      "side": 1,
      "message": "nit: suggest making this `const` to enforce that it doesn\u0027t change after the check below.",
      "revId": "19bdabbeaadfbb02bdecd80bf42504e74365078c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6e69205d_1659da55",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 15
      },
      "lineNbr": 840,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-17T18:44:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f216aeb8_6d326bc9",
      "revId": "19bdabbeaadfbb02bdecd80bf42504e74365078c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc0fa05e_da825033",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 15
      },
      "lineNbr": 845,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-17T17:26:59Z",
      "side": 1,
      "message": "I don\u0027t have enough insight into all the bugs this patch addresses, but would it suffice to call `setError()` here and below instead of aborting? That should result in graceful shader compilation failure.",
      "range": {
        "startLine": 845,
        "startChar": 12,
        "endLine": 845,
        "endChar": 30
      },
      "revId": "19bdabbeaadfbb02bdecd80bf42504e74365078c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6061f317_79418c1b",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 15
      },
      "lineNbr": 845,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-17T18:44:45Z",
      "side": 1,
      "message": "I think it\u0027s better to completely bail out here. `setError` is not guaranteed to leave Subzero in a stable state after sortAndCombineAlloca - as far as I can tell by auditing all of the `hasError()` calls -  which is what we were worried about here [1].\n\n[1] https://swiftshader-review.googlesource.com/c/SwiftShader/+/71928/comment/8364e8c4_e35d56c8/",
      "parentUuid": "bc0fa05e_da825033",
      "range": {
        "startLine": 845,
        "startChar": 12,
        "endLine": 845,
        "endChar": 30
      },
      "revId": "19bdabbeaadfbb02bdecd80bf42504e74365078c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78ff58fa_78c7b958",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 15
      },
      "lineNbr": 845,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-18T15:12:02Z",
      "side": 1,
      "message": "I agree aborting is better than continuing when there\u0027s a significant potential for a security issue down the road. But I should caution that to my knowledge this would be the first explicit abort in SwiftShader that is trivial to trigger. Especially with WebGPU where one can explicitly request a fallback driver this might create a robustness issue.\n\nChrome has a mechanism where if a GPU driver crashes three times it will fall back to SwiftShader, and last time I checked (years ago) if SwiftShader crashes three times the GPU process is disabled altogether. I\u0027m not 100% sure if that\u0027s still the case. Also, there was a desire to eliminate some of Skia\u0027s CPU rendering paths (especially the one with programmable shading) and just use SwiftShader, thus necessitating to always have a usable GPU process.\n\nAs far as I\u0027m aware it\u0027s actually benign to continue compilation with Subzero when the stack size limit is exceeded. It\u0027s just numbers. The actual overflow happens on executing the generated code. My concern for [1] was that if `llvm::report_fatal_error()` does not abort and `sortAndCombineAllocas()` returns early things would be in a more unstable state than just continuing.\n\nAnyway, I haven\u0027t done a thorough investigation (and don\u0027t have access to all the bug reports) to evaluate the balance between security risk and robustness risk. I\u0027ll leave it to other reviewers to make that assessment. The most important part is people being aware of the tradeoff and to take it into account for future design changes.",
      "parentUuid": "6061f317_79418c1b",
      "range": {
        "startLine": 845,
        "startChar": 12,
        "endLine": 845,
        "endChar": 30
      },
      "revId": "19bdabbeaadfbb02bdecd80bf42504e74365078c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b05f1f0e_948ad021",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 15
      },
      "lineNbr": 845,
      "author": {
        "id": 101121
      },
      "writtenOn": "2023-07-21T20:16:10Z",
      "side": 1,
      "message": "with respect to WebGPU, WGSL allows for failures for undiagnosed and unexpected reasons. Causes can include:\n\n\"The shaders are too complex, exceeding the capabilities of the implementation, but in a way not easily captured by prescribed limits.\"\n\nhttps://gpuweb.github.io/gpuweb/wgsl/#uncategorized-error \n\nSo there isn\u0027t a robustness problem from WebGPU\u0027s perspective.",
      "parentUuid": "78ff58fa_78c7b958",
      "range": {
        "startLine": 845,
        "startChar": 12,
        "endLine": 845,
        "endChar": 30
      },
      "revId": "19bdabbeaadfbb02bdecd80bf42504e74365078c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef540be6_840db049",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 15
      },
      "lineNbr": 845,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-22T01:37:06Z",
      "side": 1,
      "message": "Thanks David, great to see that WebGPU/WGSL explicitly specifies the possibility of such errors.\n\nThat said, my robustness concern wasn\u0027t about reporting a compilation error, but about it causing process termination. I think the closest thing the spec describes is device loss, but I couldn\u0027t immediately find any spec text stating it could be the result of fatal compilation errors.",
      "parentUuid": "b05f1f0e_948ad021",
      "range": {
        "startLine": 845,
        "startChar": 12,
        "endLine": 845,
        "endChar": 30
      },
      "revId": "19bdabbeaadfbb02bdecd80bf42504e74365078c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    }
  ]
}