{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1dfa0e02_8dc3bd39",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-14T05:01:41Z",
      "side": 1,
      "message": "It would be better to treat the root cause rather than the symptoms. For http://crbug.com/1427865 the amount of local storage required for the array of 0x7ffffff vectors is absurdly excessive and will cause issues not just in SwiftShader\u0027s Subzero JIT but in many other parts of various graphics stacks.\n\nI suggest to address this in ANGLE for all backends at once by limiting array sizes to something approaching reason like 4096. Note this is still much higher than the register limit of 255 on NVIDIA\u0027s latest architecture, and way higher than the maximum of 32 registers to achieve full occupancy.\n\nSee also my prior discussion at http://crbug.com/1248665",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e929f49f_2ce56152",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 46365
      },
      "writtenOn": "2023-07-14T05:26:14Z",
      "side": 1,
      "message": "FWIW, we\u0027re also doing that: https://chromium-review.googlesource.com/c/angle/angle/+/4685307\n\nThough the limit is a few MBs, because there\u0027s a dEQP test with a shader of a million ints üòê. The shader just uses `.length()` though so if ANGLE did dead-code elimination we _could_ reduce that limit greatly.\n\nNo short-term plan for DCE at the moment though.",
      "parentUuid": "1dfa0e02_8dc3bd39",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1991ec20_8a5aa460",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-14T05:30:32Z",
      "side": 1,
      "message": "Limiting array sizes to something approaching reason like 4096 is very similar to the approach taken in crbug.com/1427865. This was easily bypassable by creating many smaller sized arrays which would eventually lead to an overflow here. Take a look at crbug.com/1431761, a variant of crbug.com/1427865, which was a variant of crbug.com/1248665. This will likely be a never ending cycle of bypasses that reach this bug (as we\u0027ve seen with two new variants: crbug.com/1464038 and crbug.com/1464680).\n\nThe root-cause of this issue is that there is an integer overflow in IceCfg::sortAndCombineAllocas that leads to an underallocation. To prevent more variants of this issue we need to address the root cause in SwiftShader. (Also the above strategy doesn\u0027t work with WebGPU which is now also a SwiftShader user :)).",
      "parentUuid": "1dfa0e02_8dc3bd39",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b100f40_d921dde6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-14T07:59:08Z",
      "side": 1,
      "message": "Thanks for the references and for pointing out that ANGLE now rejects shaders exceeding a total limit of local variable storage! Unfortunately I don\u0027t have access to http://crbug.com/1464038 nor http://crbug.com/1464680, but I assume it\u0027s essentially the same issue but for WebGPU?\n\nIn that case I don\u0027t think this would become an endless cycle of bypasses. It just needs similar checks in Dawn/Tint to ensure shaders can be reasonably expected to compile and run without issues. Anything else should be regarded a security risk.\n\nI think it\u0027s important to point out that Vulkan is inherently extremely unsafe, and except for drivers implementing the Vulkan SC spec variant, vendors make little or no safety guarantees about non-typical usage. Instead they prioritize performance. Hence it is entirely the browser\u0027s responsibility to make it safe for web usage. That necessarily goes beyond what the Vulkan spec may or may not specify.\n\nSwiftShader is your canary in the coal mine. If you make it robust against outlier scenarios it will mask issues that the browser should prevent. What I\u0027m trying to say is that even though this is a serious security issue in Subzero and it makes sense to patch it I don\u0027t think that should excuse the browser from making changes that prevent it in the first place. So I find it dangerous to label the Subzero code as \"root cause\" when it\u0027s the browser making extra security demands and not yet fulfilling its shader sanity checking duties.",
      "parentUuid": "1991ec20_8a5aa460",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71828fc1_dbdf2645",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-14T13:29:40Z",
      "side": 1,
      "message": "\u003e  Unfortunately I don\u0027t have access to http://crbug.com/1464038 nor http://crbug.com/1464680, but I assume it\u0027s essentially the same issue but for WebGPU?\n\nhttp://crbug.com/1464038 and http://crbug.com/1464680 are two new methods to bypass the ANGLE hardening and reach this bug. \n\n\u003e What I\u0027m trying to say is that even though this is a serious security issue in Subzero and it makes sense to patch it I don\u0027t think that should excuse the browser from making changes that prevent it in the first place. So I find it dangerous to label the Subzero code as \"root cause\" when it\u0027s the browser making extra security demands and not yet fulfilling its shader sanity checking duties.\n\nI agree with you that we should continue reducing the subset of valid GLSL we allow on the web by making changes to the ANGLE translaotr. However, it is not always the best avenue to fix security bugs as there are often simple ways to bypass sanitization especially when the sanitization is done over an AST that has no context about the underlying Shader compiler, and the underlying security issue is in a backend optimization. We need to both fix security vulnerabilities by reducing the subset of GLSL with ANGLE shader sanitization while also fixing the underlying issues at their root cause in SwiftShader/UMDs.",
      "parentUuid": "9b100f40_d921dde6",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "54b381fe_d0efa8cc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5220
      },
      "writtenOn": "2023-07-14T18:18:37Z",
      "side": 1,
      "message": "Note that we took the security researcher\u0027s original exploit and reduced the size of the arrays so they fit underneath ANGLE\u0027s new size checks for all variables in the shader, and were still able to provoke a crash inside SwiftShader\u0027s sw::DrawCall::run. We aren\u0027t sure whether that crash can be weaponized, but it is important to eliminate the possibility. We are concerned that reducing ANGLE\u0027s current size checks any further may break real-world content.",
      "parentUuid": "71828fc1_dbdf2645",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9bedd45c_28ded7e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-16T09:04:48Z",
      "side": 1,
      "message": "\u003e ...there are often simple ways to bypass sanitization especially when the sanitization is done over an AST that has no context about the underlying Shader compiler, and the underlying security issue is in a backend optimization.\n\nNote that the OpenGL spec allows shader compilation to fail for implementation-specific resource limitations, and that it makes no assumptions about optimizations taking place. ANGLE as a (Web)GL implementation can definitely use that to its advantage to reject suspicious shaders out of security concerns even just by looking at the AST. That reduces it to the practical issue Ken pointed out:\n\n\u003e We are concerned that reducing ANGLE\u0027s current size checks any further may break real-world content.\n\nDetermining whether that\u0027s actually the case would be really useful. Could some metrics be collected for this?\n\nIn my mind there should still be quite a large gap between a contrived-but-legit shader, and one apparently trying to exploit 32-bit arithmethic overflow. Also note that forcing a couple of ShaderToy samples to have to be rewritten would be a small price to pay for protecting users.\n\nThere are hundreds more places in Subzero\u0027s stack related arithmetic alone that assume we\u0027re dealing with numbers that stay well clear of causing numeric overflow. Focusing on just the ones identified by the security researchers is like removing one needle in a haystack containing hundreds. One should really be focusing on making sure that the assumptions made about small-ish numbers are true. Then it doesn\u0027t really matter what the actual arithmetic formulas look like. 32-bit variables are very large. Operations on them only become dangerous, in lots of different places, when allowing values that approach their limit to be passed down.",
      "parentUuid": "54b381fe_d0efa8cc",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09574a26_6c49e7b6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 101891
      },
      "writtenOn": "2023-07-16T15:30:24Z",
      "side": 1,
      "message": "This discussion illustrates the scale of the challenge ahead. We understand graphics libraries tend to assume their input is benign, which requires embedders to attempt to sanitize inputs. On the other hand, in this case input sanitization is equivalent to comprehensively enumerating all forms of badness within an expressive language, which we also understand to be generally unsolvable with known computer science.\n\nThis situation has strong parallels to Chrome using V8 to execute JavaScript from untrustworthy sources. However, in that case V8 benefits from both residing in a tight sandbox as well as Site Isolation to minimize the impact of V8 exploitation. As you know, code in the Chrome GPU process effectively has neither of those benefits. \n\nIt will be some time until a happier architectural solution is available for Chrome, so as we establish what principles to apply when deciding whether to mitigate a bug class with sanitization or point fixes, my request is to please stay flexible and help security fixes land (as you are doing, thank you!) even if we know they don\u0027t eliminate an entire bug class, and especially when they address a known bug without causing major disruption.",
      "parentUuid": "9bedd45c_28ded7e4",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e62e0db6_54390a58",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-17T16:22:39Z",
      "side": 1,
      "message": "\u003e Note that the OpenGL spec allows shader compilation to fail for implementation-specific resource limitations, and that it makes no assumptions about optimizations taking place. ANGLE as a (Web)GL implementation can definitely use that to its advantage to reject suspicious shaders out of security concerns even just by looking at the AST. \n\nWe are continuing to reduce attack surface that can be hit in SwiftShader and other UMDs by further restricting the subset of WebGL SL allowed on the web, and we are not going to quit using this strategy. However, bugs will still pop up in SwiftShader/UMDs - like this bug in sortAndCombinAllocas - that should also be addressed at their root cause within their respective codebases.\n\nFor example, if SwiftShader had a use-after-free in a backend optimization (like sortAndCombineAllocas) would you still argue that we attempt to reduce the subset of WebGL SL in a way that can\u0027t hit that use-after-free? This bug in sortAndCombineAllocas is a bug like that, that can be hit with a subset of GLSL that is difficult to reduce any further and by doing so we are creating code-golf like challenges for security researchers (which are very fun puzzles for us I might add :] https://crbug.com/1431761).\n\n\u003e There are hundreds more places in Subzero\u0027s stack related arithmetic alone that assume we\u0027re dealing with numbers that stay well clear of causing numeric overflow. Focusing on just the ones identified by the security researchers is like removing one needle in a haystack containing hundreds.\n\nI\u0027m not sure if this is a super healthy place for a codebase to be in, especially if we are coalescing integer additions in other areas of the codebase because even if we reduce the maximum variable size to `2`, `2 + 2 + ... + 2` will still overflow.",
      "parentUuid": "09574a26_6c49e7b6",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b659d05c_14ad44f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-17T17:26:59Z",
      "side": 1,
      "message": "\u003e This discussion illustrates the scale of the challenge ahead. We understand graphics libraries tend to assume their input is benign, which requires embedders to attempt to sanitize inputs.\n\nWell put!\n\n\u003e On the other hand, in this case input sanitization is equivalent to comprehensively enumerating all forms of badness within an expressive language, which we also understand to be generally unsolvable with known computer science.\n\n\u003e This situation has strong parallels to Chrome using V8 to execute JavaScript from untrustworthy sources.\n\nFortunately it\u0027s not quite that bad. Graphics shaders have access to only a handful of resource types, and can\u0027t make external calls. Robust resource accesses is largely a solved problem (in theory).\n\nBut these stack overflow related issues have been remarkably recurrent. I don\u0027t think they have to be though. We can solve this with known computer science and sensible policy.\n\nThat said I applaud any effort to provide addition defence-in-depth to avoid endangering users and Chrome\u0027s reputation if/when input sanitization or robustness measures slip up. I\u0027ve spent years promoting the idea of site isolation for SwiftShader (https://issuetracker.google.com/issues/160140127) but it didn\u0027t gain enough traction to kick off the project. Note that while site isolation for all of graphics could be provided by Chrome itself, there\u0027s an argument to be made that potentially escaping the shader execution environment and accessing other CPU resources is uniquely a SwiftShader issue. Project Bunker would also offer benefits beyond security, and seems like a smaller effort overall.\n\nAnyway, it\u0027s exciting to see SwiftShader getting enabled for WebGPU and I\u0027d",
      "parentUuid": "09574a26_6c49e7b6",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b7c5a99c_9579c294",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-22T01:37:06Z",
      "side": 1,
      "message": "\u003e if SwiftShader had a use-after-free in a backend optimization (like sortAndCombineAllocas) would you still argue that we attempt to reduce the subset of WebGL SL in a way that can\u0027t hit that use-after-free?\n\nPossibly. It depends on whether the vulnerability can be triggered with ordinary usage of the API or whether it requires a contrived scenario one wouldn\u0027t encounter in legit real-world applications.\n\nSwiftShader had a case of the former a few years ago in its handling of compressed textures, involving lifetimes of images and descriptors referencing them. While unommon, the sequence of API calls leading to the use-after-free was not disallowed by the spec. It was fixed promptly and Vulkan unit tests were submitted to and accepted by Khronos, as well as a spec clarification. Android even implemented a system-level workaround since they found the test to be failing on some shipping GPU drivers.\n\nIn contrast I recall a case where a Vulkan unit test involving graphics memory allocation was rejected by Khronos because it was too specific for a convoluted edge case and exceeded Vulkan\u0027s security guarantees. We ended up doing input sanitation at the browser level, and writing a unit test for that.\n\nGranted, sometimes it\u0027s less clear-cut if something is legitimate usage or deliberate abuse, or who should take responsibility to prevent badness. Sometimes adding complexity in multiple codebases for defense-in-depth is totally justified. I just think it would be a mistake to always put blame on the library in which the vulnerability occurs. By that standard a lot of CRT functions shouldn\u0027t exist. It always requires taking a broader look to arrive at a superior solution.\n\n\u003e I\u0027m not sure if this is a super healthy place for a codebase to be in...\n\nIt may have that appearance, but this is just a reality of software engineering. I\u0027m sure the vast majority of projects on GitHub which allocate and free memory have use-after-free vulnerabilities or similar. It\u0027s just part of the design tradeoffs being made. Chrome itself is no different. It wouldn\u0027t be used for the UI and controls of the SpaceX Dragon if it had to run content from untrusted sources. It\u0027s just not written to such a standard. It would require compromises to the other four S\u0027s of its core principles if Security trumped everything.\n\nInteger overflow prevention in particular is not something every project should prioritize. As Chris put it, it\u0027s reasonable for a lot of user-level software to \"tend to assume their input is benign\" and put the responsibility on the caller to make sure that\u0027s the case if security is of significant concern.\n\nIt\u0027s a luxury that SwiftShader is even open source and controlled by Google. The DirectX shader compiler is known to crash for a lot of input that goes only slightly beyond typical usage. Must be a lot of unknown security nightmares in there, and one can only hope they\u0027re discovered by the good guys first. Workarounds for the known issues are based on just educated guesses. SwiftShader on the other hand offers the opportunity to take a deep peek inside and reach a better solution overall, if one looks beyond just the site where unintended behavior was observed.\n\n\u003e ...especially if we are coalescing integer additions in other areas of the codebase because even if we reduce the maximum variable size to 2, 2 + 2 + ... + 2 will still overflow.\n\nActually, for a lot of cases, it won\u0027t. SPIR-V instruction results (including `OpVariable`s which are essentially alloca\u0027s) have an \u003cid\u003e which is a 32-bit word but their value is bound to a maximum, typically 4M. This simple measure alone probably prevents a large number of potential exploits from actually being achievable or practical. It\u0027s no panacea, of course, but I think it illustrates there are more effective ways to balance design goals and engineering realities than to expect every integer operation to be checked for arithmetic overflow.\n\nNow that I think of it, it should be quite straightforward to check after running the SPIR-V optimizer that the total alloca size is modest, and eliminate every potential for overflow in drivers. But if I recall correctly, ANGLE doesn\u0027t run the SPIR-V optimizer because it expects the driver to optimize things anyway. That\u0027s a fair assumption but there\u0027s no guarantee their optimizer handles all the same things as the official SPIR-V optimizer. I at one point proposed addressing this dilemma of who does what optimization by adding metadata to the SPIR-V binary, but it was met with resistance, claiming drivers could misinterpret or abuse the information and cause an increase in miscompiles. I think that\u0027s debatable and should be weighted against the advantages (faster compiles, faster execution, and increased security), but here we are.\n\nSorry about the long response. There\u0027s just a lot of ground to cover and I hope there\u0027s a bit of useful knowledge transfer in there for everyone.",
      "parentUuid": "b659d05c_14ad44f1",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8364e8c4_e35d56c8",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 6
      },
      "lineNbr": 844,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-14T05:01:41Z",
      "side": 1,
      "message": "Is it guaranteed that this puts things in a safe state?",
      "range": {
        "startLine": 844,
        "startChar": 6,
        "endLine": 844,
        "endChar": 30
      },
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1260ef17_dac2bee2",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 6
      },
      "lineNbr": 844,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-14T05:30:32Z",
      "side": 1,
      "message": "llvm::report_fatal_error` is guaranteed to halt the process turning this edge-case from a security bug into a stability bug (which is what we want to happen when an assumption we made about a security guarantee that leads to code execution is not met).\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/swiftshader/third_party/subzero/src/IceRegAlloc.cpp;l\u003d271;drc\u003d6649bd025e0106c372d624a736a6dfc7b8f37404",
      "parentUuid": "8364e8c4_e35d56c8",
      "range": {
        "startLine": 844,
        "startChar": 6,
        "endLine": 844,
        "endChar": 30
      },
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eaa0f145_2688abea",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 6
      },
      "lineNbr": 844,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-14T07:59:08Z",
      "side": 1,
      "message": "Thanks for verifying that!",
      "parentUuid": "1260ef17_dac2bee2",
      "range": {
        "startLine": 844,
        "startChar": 6,
        "endLine": 844,
        "endChar": 30
      },
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0cfba82b_a51ab91c",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 6
      },
      "lineNbr": 851,
      "author": {
        "id": 46365
      },
      "writtenOn": "2023-07-14T05:23:59Z",
      "side": 1,
      "message": "This pattern is repeated a few times, please add a helper in the anonymous namespace above like:\n\n```\nbool AdditionOverflowsInt(uint32_t a, uint32_t b)\n{\n    return a + b \u003c a || a + b \u003e INT32_MAX;\n}\n```\n\nOr since return is not reached after `llvm::report_fatal_error`, might as well move the whole logic to that function and call it `ReportFatalErrorOnOverflow(a, b)`",
      "range": {
        "startLine": 850,
        "startChar": 8,
        "endLine": 851,
        "endChar": 40
      },
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9cf433ca_75bdc72f",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 6
      },
      "lineNbr": 851,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-14T05:46:16Z",
      "side": 1,
      "message": "Good idea! I went with the first suggestion so we could keep the \"return; // NOTREACHED\". I think in a follow-up CL when we add safe-math we\u0027ll have something more similar to what we do in ANGLE and do an `.IsValid()` check in the if statements.",
      "parentUuid": "0cfba82b_a51ab91c",
      "range": {
        "startLine": 850,
        "startChar": 8,
        "endLine": 851,
        "endChar": 40
      },
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    }
  ]
}