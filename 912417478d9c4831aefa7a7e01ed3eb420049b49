{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1dfa0e02_8dc3bd39",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-14T05:01:41Z",
      "side": 1,
      "message": "It would be better to treat the root cause rather than the symptoms. For http://crbug.com/1427865 the amount of local storage required for the array of 0x7ffffff vectors is absurdly excessive and will cause issues not just in SwiftShader\u0027s Subzero JIT but in many other parts of various graphics stacks.\n\nI suggest to address this in ANGLE for all backends at once by limiting array sizes to something approaching reason like 4096. Note this is still much higher than the register limit of 255 on NVIDIA\u0027s latest architecture, and way higher than the maximum of 32 registers to achieve full occupancy.\n\nSee also my prior discussion at http://crbug.com/1248665",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e929f49f_2ce56152",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 46365
      },
      "writtenOn": "2023-07-14T05:26:14Z",
      "side": 1,
      "message": "FWIW, we\u0027re also doing that: https://chromium-review.googlesource.com/c/angle/angle/+/4685307\n\nThough the limit is a few MBs, because there\u0027s a dEQP test with a shader of a million ints üòê. The shader just uses `.length()` though so if ANGLE did dead-code elimination we _could_ reduce that limit greatly.\n\nNo short-term plan for DCE at the moment though.",
      "parentUuid": "1dfa0e02_8dc3bd39",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1991ec20_8a5aa460",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-14T05:30:32Z",
      "side": 1,
      "message": "Limiting array sizes to something approaching reason like 4096 is very similar to the approach taken in crbug.com/1427865. This was easily bypassable by creating many smaller sized arrays which would eventually lead to an overflow here. Take a look at crbug.com/1431761, a variant of crbug.com/1427865, which was a variant of crbug.com/1248665. This will likely be a never ending cycle of bypasses that reach this bug (as we\u0027ve seen with two new variants: crbug.com/1464038 and crbug.com/1464680).\n\nThe root-cause of this issue is that there is an integer overflow in IceCfg::sortAndCombineAllocas that leads to an underallocation. To prevent more variants of this issue we need to address the root cause in SwiftShader. (Also the above strategy doesn\u0027t work with WebGPU which is now also a SwiftShader user :)).",
      "parentUuid": "1dfa0e02_8dc3bd39",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b100f40_d921dde6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-14T07:59:08Z",
      "side": 1,
      "message": "Thanks for the references and for pointing out that ANGLE now rejects shaders exceeding a total limit of local variable storage! Unfortunately I don\u0027t have access to http://crbug.com/1464038 nor http://crbug.com/1464680, but I assume it\u0027s essentially the same issue but for WebGPU?\n\nIn that case I don\u0027t think this would become an endless cycle of bypasses. It just needs similar checks in Dawn/Tint to ensure shaders can be reasonably expected to compile and run without issues. Anything else should be regarded a security risk.\n\nI think it\u0027s important to point out that Vulkan is inherently extremely unsafe, and except for drivers implementing the Vulkan SC spec variant, vendors make little or no safety guarantees about non-typical usage. Instead they prioritize performance. Hence it is entirely the browser\u0027s responsibility to make it safe for web usage. That necessarily goes beyond what the Vulkan spec may or may not specify.\n\nSwiftShader is your canary in the coal mine. If you make it robust against outlier scenarios it will mask issues that the browser should prevent. What I\u0027m trying to say is that even though this is a serious security issue in Subzero and it makes sense to patch it I don\u0027t think that should excuse the browser from making changes that prevent it in the first place. So I find it dangerous to label the Subzero code as \"root cause\" when it\u0027s the browser making extra security demands and not yet fulfilling its shader sanity checking duties.",
      "parentUuid": "1991ec20_8a5aa460",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71828fc1_dbdf2645",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-14T13:29:40Z",
      "side": 1,
      "message": "\u003e  Unfortunately I don\u0027t have access to http://crbug.com/1464038 nor http://crbug.com/1464680, but I assume it\u0027s essentially the same issue but for WebGPU?\n\nhttp://crbug.com/1464038 and http://crbug.com/1464680 are two new methods to bypass the ANGLE hardening and reach this bug. \n\n\u003e What I\u0027m trying to say is that even though this is a serious security issue in Subzero and it makes sense to patch it I don\u0027t think that should excuse the browser from making changes that prevent it in the first place. So I find it dangerous to label the Subzero code as \"root cause\" when it\u0027s the browser making extra security demands and not yet fulfilling its shader sanity checking duties.\n\nI agree with you that we should continue reducing the subset of valid GLSL we allow on the web by making changes to the ANGLE translaotr. However, it is not always the best avenue to fix security bugs as there are often simple ways to bypass sanitization especially when the sanitization is done over an AST that has no context about the underlying Shader compiler, and the underlying security issue is in a backend optimization. We need to both fix security vulnerabilities by reducing the subset of GLSL with ANGLE shader sanitization while also fixing the underlying issues at their root cause in SwiftShader/UMDs.",
      "parentUuid": "9b100f40_d921dde6",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "54b381fe_d0efa8cc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5220
      },
      "writtenOn": "2023-07-14T18:18:37Z",
      "side": 1,
      "message": "Note that we took the security researcher\u0027s original exploit and reduced the size of the arrays so they fit underneath ANGLE\u0027s new size checks for all variables in the shader, and were still able to provoke a crash inside SwiftShader\u0027s sw::DrawCall::run. We aren\u0027t sure whether that crash can be weaponized, but it is important to eliminate the possibility. We are concerned that reducing ANGLE\u0027s current size checks any further may break real-world content.",
      "parentUuid": "71828fc1_dbdf2645",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9bedd45c_28ded7e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-16T09:04:48Z",
      "side": 1,
      "message": "\u003e ...there are often simple ways to bypass sanitization especially when the sanitization is done over an AST that has no context about the underlying Shader compiler, and the underlying security issue is in a backend optimization.\n\nNote that the OpenGL spec allows shader compilation to fail for implementation-specific resource limitations, and that it makes no assumptions about optimizations taking place. ANGLE as a (Web)GL implementation can definitely use that to its advantage to reject suspicious shaders out of security concerns even just by looking at the AST. That reduces it to the practical issue Ken pointed out:\n\n\u003e We are concerned that reducing ANGLE\u0027s current size checks any further may break real-world content.\n\nDetermining whether that\u0027s actually the case would be really useful. Could some metrics be collected for this?\n\nIn my mind there should still be quite a large gap between a contrived-but-legit shader, and one apparently trying to exploit 32-bit arithmethic overflow. Also note that forcing a couple of ShaderToy samples to have to be rewritten would be a small price to pay for protecting users.\n\nThere are hundreds more places in Subzero\u0027s stack related arithmetic alone that assume we\u0027re dealing with numbers that stay well clear of causing numeric overflow. Focusing on just the ones identified by the security researchers is like removing one needle in a haystack containing hundreds. One should really be focusing on making sure that the assumptions made about small-ish numbers are true. Then it doesn\u0027t really matter what the actual arithmetic formulas look like. 32-bit variables are very large. Operations on them only become dangerous, in lots of different places, when allowing values that approach their limit to be passed down.",
      "parentUuid": "54b381fe_d0efa8cc",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09574a26_6c49e7b6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 101891
      },
      "writtenOn": "2023-07-16T15:30:24Z",
      "side": 1,
      "message": "This discussion illustrates the scale of the challenge ahead. We understand graphics libraries tend to assume their input is benign, which requires embedders to attempt to sanitize inputs. On the other hand, in this case input sanitization is equivalent to comprehensively enumerating all forms of badness within an expressive language, which we also understand to be generally unsolvable with known computer science.\n\nThis situation has strong parallels to Chrome using V8 to execute JavaScript from untrustworthy sources. However, in that case V8 benefits from both residing in a tight sandbox as well as Site Isolation to minimize the impact of V8 exploitation. As you know, code in the Chrome GPU process effectively has neither of those benefits. \n\nIt will be some time until a happier architectural solution is available for Chrome, so as we establish what principles to apply when deciding whether to mitigate a bug class with sanitization or point fixes, my request is to please stay flexible and help security fixes land (as you are doing, thank you!) even if we know they don\u0027t eliminate an entire bug class, and especially when they address a known bug without causing major disruption.",
      "parentUuid": "9bedd45c_28ded7e4",
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8364e8c4_e35d56c8",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 6
      },
      "lineNbr": 844,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-14T05:01:41Z",
      "side": 1,
      "message": "Is it guaranteed that this puts things in a safe state?",
      "range": {
        "startLine": 844,
        "startChar": 6,
        "endLine": 844,
        "endChar": 30
      },
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1260ef17_dac2bee2",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 6
      },
      "lineNbr": 844,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-14T05:30:32Z",
      "side": 1,
      "message": "llvm::report_fatal_error` is guaranteed to halt the process turning this edge-case from a security bug into a stability bug (which is what we want to happen when an assumption we made about a security guarantee that leads to code execution is not met).\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/swiftshader/third_party/subzero/src/IceRegAlloc.cpp;l\u003d271;drc\u003d6649bd025e0106c372d624a736a6dfc7b8f37404",
      "parentUuid": "8364e8c4_e35d56c8",
      "range": {
        "startLine": 844,
        "startChar": 6,
        "endLine": 844,
        "endChar": 30
      },
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eaa0f145_2688abea",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 6
      },
      "lineNbr": 844,
      "author": {
        "id": 5755
      },
      "writtenOn": "2023-07-14T07:59:08Z",
      "side": 1,
      "message": "Thanks for verifying that!",
      "parentUuid": "1260ef17_dac2bee2",
      "range": {
        "startLine": 844,
        "startChar": 6,
        "endLine": 844,
        "endChar": 30
      },
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0cfba82b_a51ab91c",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 6
      },
      "lineNbr": 851,
      "author": {
        "id": 46365
      },
      "writtenOn": "2023-07-14T05:23:59Z",
      "side": 1,
      "message": "This pattern is repeated a few times, please add a helper in the anonymous namespace above like:\n\n```\nbool AdditionOverflowsInt(uint32_t a, uint32_t b)\n{\n    return a + b \u003c a || a + b \u003e INT32_MAX;\n}\n```\n\nOr since return is not reached after `llvm::report_fatal_error`, might as well move the whole logic to that function and call it `ReportFatalErrorOnOverflow(a, b)`",
      "range": {
        "startLine": 850,
        "startChar": 8,
        "endLine": 851,
        "endChar": 40
      },
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9cf433ca_75bdc72f",
        "filename": "third_party/subzero/src/IceCfg.cpp",
        "patchSetId": 6
      },
      "lineNbr": 851,
      "author": {
        "id": 101888
      },
      "writtenOn": "2023-07-14T05:46:16Z",
      "side": 1,
      "message": "Good idea! I went with the first suggestion so we could keep the \"return; // NOTREACHED\". I think in a follow-up CL when we add safe-math we\u0027ll have something more similar to what we do in ANGLE and do an `.IsValid()` check in the if statements.",
      "parentUuid": "0cfba82b_a51ab91c",
      "range": {
        "startLine": 850,
        "startChar": 8,
        "endLine": 851,
        "endChar": 40
      },
      "revId": "912417478d9c4831aefa7a7e01ed3eb420049b49",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    }
  ]
}