{
  "comments": [
    {
      "key": {
        "uuid": "52d984d7_111f3c8d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 7,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-08-30T17:07:27Z",
      "side": 1,
      "message": "Isn\u0027t it float+bitcast, actually?",
      "range": {
        "startLine": 7,
        "startChar": 10,
        "endLine": 7,
        "endChar": 23
      },
      "revId": "58216e1532b96ef6d07a67ddb01948cc8d93a45a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd4feff1_5320865d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 7,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-08-30T19:15:47Z",
      "side": 1,
      "message": "I just tried to reconstruct what goes on here exactly. My understanding from the description is that:\n1) Integer value which represents an SNaN gets bitcast to float, using reinterpret_cast\u003cfloat\u003e(uint).\n2) LLVM takes the float to create a constant float IR node, converting it to QNaN in the process.\n3) Float constant gets Reactor bitcast to integer, using As\u003cInt\u003e(Float) essentially.\n\nI can\u0027t seem to reproduce that in a Reactor unit test though. Might be platform specific though...",
      "parentUuid": "52d984d7_111f3c8d",
      "range": {
        "startLine": 7,
        "startChar": 10,
        "endLine": 7,
        "endChar": 23
      },
      "revId": "58216e1532b96ef6d07a67ddb01948cc8d93a45a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3507f873_a84f8ffd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 7,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-08-30T19:47:29Z",
      "side": 1,
      "message": "Follow-up in b/140302841",
      "parentUuid": "bd4feff1_5320865d",
      "range": {
        "startLine": 7,
        "startChar": 10,
        "endLine": 7,
        "endChar": 23
      },
      "revId": "58216e1532b96ef6d07a67ddb01948cc8d93a45a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1339e79c_6db3018d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-08-30T17:12:18Z",
      "side": 1,
      "message": "What if we actually wanted a NaN float constant? Clearly not in this case, but just wondering if this is going to bite us again, what LLVM\u0027s stated behavior is, and how to work around it (bitcast from integer constant)?\n\nJust trying to fully understand these \"liberties\" and whether they match SPIR-V behavior.",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 9,
        "endChar": 45
      },
      "revId": "58216e1532b96ef6d07a67ddb01948cc8d93a45a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc3f58a9_bbda2de7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 6982
      },
      "writtenOn": "2019-08-30T18:27:44Z",
      "side": 1,
      "message": "The only mangling that is happening is SNaN -\u003e QNaN conversion. NaN constants will still produce NaNs, just not necessarily the same bit pattern.",
      "parentUuid": "1339e79c_6db3018d",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 9,
        "endChar": 45
      },
      "revId": "58216e1532b96ef6d07a67ddb01948cc8d93a45a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "062e77db_cb85db72",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 6982
      },
      "writtenOn": "2019-08-30T18:30:05Z",
      "side": 1,
      "message": "As for SPIRV rules -- this is OK. We will have to *describe* some aspects of our behavior when we do KHR_float_controls support.",
      "parentUuid": "dc3f58a9_bbda2de7",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 9,
        "endChar": 45
      },
      "revId": "58216e1532b96ef6d07a67ddb01948cc8d93a45a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "593e92c6_2488d290",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-08-30T19:15:47Z",
      "side": 1,
      "message": "Right, I meant what if we want to keep the exact same bit pattern, like an SNaN. They can be useful as poison values. Probably just requires writing as int.",
      "parentUuid": "062e77db_cb85db72",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 9,
        "endChar": 45
      },
      "revId": "58216e1532b96ef6d07a67ddb01948cc8d93a45a",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}