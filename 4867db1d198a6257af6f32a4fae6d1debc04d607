{
  "comments": [
    {
      "key": {
        "uuid": "3da6932a_e99fb4d2",
        "filename": "src/Pipeline/SpirvShader.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1236,
      "author": {
        "id": 46365
      },
      "writtenOn": "2020-01-31T04:29:06Z",
      "side": 1,
      "message": "Thanks. I presume it\u0027s not an issue if lane 0 is inactive?",
      "revId": "4867db1d198a6257af6f32a4fae6d1debc04d607",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8173b26_4ae50f66",
        "filename": "src/Pipeline/SpirvShader.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1236,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-01-31T04:36:10Z",
      "side": 1,
      "message": "I\u0027ll have to check, but I think the spec forbids non-uniform branching of sampling operations. At least I\u0027m pretty sure GLSL ES does.",
      "parentUuid": "3da6932a_e99fb4d2",
      "revId": "4867db1d198a6257af6f32a4fae6d1debc04d607",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2f01cfbe_10f90a0a",
        "filename": "src/Pipeline/SpirvShader.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1236,
      "author": {
        "id": 46365
      },
      "writtenOn": "2020-01-31T04:43:56Z",
      "side": 1,
      "message": "I\u0027m pretty sure you can do something like:\n\n    dynamically_uniform_index \u003d ...;\n    if (some_non_uniform_condition)\n    {\n        texture(samplerArray[dynamically_uniform_index], non_uniform_coordinates);\n    }\n\n(not sure if GLES disallows that, but modern languages shouldn\u0027t)\n\nI\u0027d guess all lanes (in swiftshader) would have the same value for `dynamically_uniform_index` regardless of active or not, but just wanted to bring that to your attention, in case that\u0027s not true.\n\n---\n\nAlso, I don\u0027t know if you care to add an UNSUPPORTED if not all lanes are equal, but maybe some SPIR-V validation beforehand prevents that? Unless the SPIR-V is manipulated, I don\u0027t think any shader compiler actually generates such a code though (i.e. non_uniform_index is disallowed by all shading languages I think).",
      "parentUuid": "f8173b26_4ae50f66",
      "revId": "4867db1d198a6257af6f32a4fae6d1debc04d607",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    }
  ]
}