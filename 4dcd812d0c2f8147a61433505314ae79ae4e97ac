{
  "comments": [
    {
      "key": {
        "uuid": "a0660e5e_cfe1eee5",
        "filename": "src/Renderer/Renderer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 214,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-02-12T16:15:08Z",
      "side": 1,
      "message": "This is actually supposed to ensure that all worker threads are idle before we continue. Renderer::draw() increments the lock count and the last worker processing it decrements it in Renderer::finishRendering(). I suppose there could be a race when a new draw comes in right after sync-\u003edestruct(), but that\u0027s only possible if it\u0027s submitted from another thread than the one that\u0027s destroying the renderer.\n\nI thought that wasn\u0027t valid with OpenGL ES. Also note that we create a Renderer per es2::Context, and shared contexts merely share their resource manager. Also, you found this running the unit tests, which don\u0027t use multiple contexts/threads to my knowledge.\n\nSo I\u0027m quite curious about the root cause of this. There might be something else going on that isn\u0027t working as intended, which this patch may improve on but not fix properly.",
      "range": {
        "startLine": 214,
        "startChar": 2,
        "endLine": 214,
        "endChar": 19
      },
      "revId": "4dcd812d0c2f8147a61433505314ae79ae4e97ac",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28a132bf_cd39a58a",
        "filename": "src/Renderer/Renderer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 214,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-02-12T17:02:29Z",
      "side": 1,
      "message": "Interesting - I\u0027ll investigate further.\nI encountered a deadlock about 2 hours into the dEQP tests with this change, so I\u0027ll definitely try to get to the bottom of this.",
      "parentUuid": "a0660e5e_cfe1eee5",
      "range": {
        "startLine": 214,
        "startChar": 2,
        "endLine": 214,
        "endChar": 19
      },
      "revId": "4dcd812d0c2f8147a61433505314ae79ae4e97ac",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2499de96_d20b8f97",
        "filename": "src/Renderer/Renderer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 214,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-02-12T18:02:24Z",
      "side": 1,
      "message": "Looking at the source of Resource::destruct(), I don\u0027t see anything that would block until the worker threads have finished:\n\n\tvoid Resource::destruct()\n\t{\n\t\tcriticalSection.lock();\n\n\t\tif(count \u003d\u003d 0 \u0026\u0026 !blocked)\n\t\t{\n\t\t\tcriticalSection.unlock();\n\n\t\t\tdelete this;\n\n\t\t\treturn;\n\t\t}\n\n\t\torphaned \u003d true;\n\n\t\tcriticalSection.unlock();\n\t}\n\nIt looks like if there are worker threads, orphaned will get set to true and the resource will be freed when next unlocked. Am I missing something?",
      "parentUuid": "28a132bf_cd39a58a",
      "range": {
        "startLine": 214,
        "startChar": 2,
        "endLine": 214,
        "endChar": 19
      },
      "revId": "4dcd812d0c2f8147a61433505314ae79ae4e97ac",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f480f8f7_f59ddc76",
        "filename": "src/Renderer/Renderer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 214,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-02-20T17:48:08Z",
      "side": 1,
      "message": "You\u0027re totally right. Resource::destruct() is asynchronous so it doesn\u0027t block. The proper way to destruct it synchronously is to obtain an \u0027EXCLUSIVE\u0027 lock, destruct() it, then unlock. Might even be a single method (merging the critical sections into one) if that\u0027s not less understandable.\n\nI think waiting on sync, then terminating the threads feels cleaner than the other way around, since it\u0027s not obvious that terminateThreads() waits for the threads to go idle (might change at some point). Mind flipping this back around and doing the synchronous destruct?",
      "parentUuid": "2499de96_d20b8f97",
      "range": {
        "startLine": 214,
        "startChar": 2,
        "endLine": 214,
        "endChar": 19
      },
      "revId": "4dcd812d0c2f8147a61433505314ae79ae4e97ac",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    }
  ]
}