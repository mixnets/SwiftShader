{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7f91a08c_e4eb6998",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 5005
      },
      "writtenOn": "2022-02-15T20:26:03Z",
      "side": 1,
      "message": "Yes and no. Even if descriptor memory was unlimited, it has the disadvantage that the data would have to be rewritten if you wanted to update it. With uniforms in a buffer you can swap buffers by updating one descriptor, so the buffer data itself can be written asynchronously. Serves different purposes.",
      "range": {
        "startLine": 9,
        "startChar": 24,
        "endLine": 10,
        "endChar": 6
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "57a9ebc2_9542bf02",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-15T20:42:48Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "7f91a08c_e4eb6998",
      "range": {
        "startLine": 9,
        "startChar": 24,
        "endLine": 10,
        "endChar": 6
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b675b433_df5863a7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 11,
      "author": {
        "id": 5005
      },
      "writtenOn": "2022-02-15T20:26:03Z",
      "side": 1,
      "message": "I don\u0027t think it should be called dynamic. If anything, it\u0027s more static.",
      "range": {
        "startLine": 11,
        "startChar": 38,
        "endLine": 11,
        "endChar": 49
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "abd20e62_1af6ae1c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 11,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-15T20:42:48Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b675b433_df5863a7",
      "range": {
        "startLine": 11,
        "startChar": 38,
        "endLine": 11,
        "endChar": 49
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eed8769a_160c44ff",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 5005
      },
      "writtenOn": "2022-02-15T20:26:03Z",
      "side": 1,
      "message": "That\u0027s not a goal of inline uniform blocks.",
      "range": {
        "startLine": 12,
        "startChar": 4,
        "endLine": 12,
        "endChar": 23
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f5e7c405_871d65fa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-15T20:42:48Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "eed8769a_160c44ff",
      "range": {
        "startLine": 12,
        "startChar": 4,
        "endLine": 12,
        "endChar": 23
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cd3ff443_f7b76bac",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-14T13:02:14Z",
      "side": 1,
      "message": "I think this is the overall simplest way of implementing this. PTAL.",
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7226c133_5ee0453d",
        "filename": "src/Vulkan/VkDescriptorPool.cpp",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 5005
      },
      "writtenOn": "2022-02-15T20:26:03Z",
      "side": 1,
      "message": "I think this is a big overestimate. `maxInlineUniformBlockBindings` is the number of inline uniform blocks for the entire descriptor pool, not for each `VkDescriptorPoolSize`. It\u0027s only relevant for implementations that have an additional cost to each binding.\n\nAlso this is getting multiplied by the `descriptorCount` which for inline uniform blocks is already the size in bytes for that entire `VkDescriptorPoolSize`.",
      "range": {
        "startLine": 69,
        "startChar": 3,
        "endLine": 69,
        "endChar": 40
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f06e9bce_7f02e95e",
        "filename": "src/Vulkan/VkDescriptorPool.cpp",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-15T20:42:48Z",
      "side": 1,
      "message": "Ok, then how do we allocate multiple uniform blocks of different sizes? Or is that not allowed within a pool?",
      "parentUuid": "7226c133_5ee0453d",
      "range": {
        "startLine": 69,
        "startChar": 3,
        "endLine": 69,
        "endChar": 40
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08901a9a_97b3a235",
        "filename": "src/Vulkan/VkDescriptorPool.cpp",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 5005
      },
      "writtenOn": "2022-02-16T03:12:00Z",
      "side": 1,
      "message": "\"If multiple VkDescriptorPoolSize structures containing the same descriptor type appear in the pPoolSizes array then the pool will be created with enough storage for the total number of descriptors of each type.\"",
      "parentUuid": "f06e9bce_7f02e95e",
      "range": {
        "startLine": 69,
        "startChar": 3,
        "endLine": 69,
        "endChar": 40
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b26fdc69_43fb4efb",
        "filename": "src/Vulkan/VkDescriptorPool.cpp",
        "patchSetId": 2
      },
      "lineNbr": 69,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-16T13:42:17Z",
      "side": 1,
      "message": "Ok, let me give a concrete example. In the dEQP tests, they set maxInlineUniformBlockBindings to 2, specify one uniform block and one other descriptor. The test expects enough storage for 2 uniform block descriptors and one of the other type.\n\nIf multiple uniform blocks are specified, but still fewer than maxInlineUniformBlockBindings, do we add the remaining ones so that they are of the largest size requested? For example:\n\nmaxInlineUniformBlockBindings is 3\none uniform block specified with size 16\none uniform block specified with size 32\nbecause maxInlineUniformBlockBindings is 3, do we add enough space for another uniform block of size 32, the largest requested size? Does that make sense?",
      "parentUuid": "08901a9a_97b3a235",
      "range": {
        "startLine": 69,
        "startChar": 3,
        "endLine": 69,
        "endChar": 40
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a335b8a_84160b28",
        "filename": "src/Vulkan/VkDescriptorSetLayout.cpp",
        "patchSetId": 2
      },
      "lineNbr": 139,
      "author": {
        "id": 5005
      },
      "writtenOn": "2022-02-15T20:26:03Z",
      "side": 1,
      "message": "I don\u0027t think we should treat them as a `BufferDescriptor`. We don\u0027t need any of its fields as far as I can tell, so the added size on top of the array of raw bytes can be zero.\n\nSome of the arithmetic in this file and others could be simplified if this function returned 1, so you can still do `descriptorCount * descriptorSize` to obtain the total byte size.",
      "range": {
        "startLine": 139,
        "startChar": 6,
        "endLine": 139,
        "endChar": 45
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0e5ed5b_3b2ef3d2",
        "filename": "src/Vulkan/VkDescriptorSetLayout.cpp",
        "patchSetId": 2
      },
      "lineNbr": 139,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-15T20:42:48Z",
      "side": 1,
      "message": "Adding a new type of descriptor here will add complexity in the SPIR-V code, and possibly everywhere we already use BufferDescriptor. I can add a new type, but I\u0027ve already tried that and it will increase the size and complexity of this CL.",
      "parentUuid": "5a335b8a_84160b28",
      "range": {
        "startLine": 139,
        "startChar": 6,
        "endLine": 139,
        "endChar": 45
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88b4e405_ef9c8b91",
        "filename": "src/Vulkan/VkDescriptorSetLayout.cpp",
        "patchSetId": 2
      },
      "lineNbr": 139,
      "author": {
        "id": 5005
      },
      "writtenOn": "2022-02-16T03:12:00Z",
      "side": 1,
      "message": "Yes this will have to be handled differently in the SPIR-V lowering code. But it\u0027s not a new type of descriptor structure though. It\u0027s just raw bytes so the logic should be straightforward.",
      "parentUuid": "a0e5ed5b_3b2ef3d2",
      "range": {
        "startLine": 139,
        "startChar": 6,
        "endLine": 139,
        "endChar": 45
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d74c2bc8_43dd351a",
        "filename": "src/Vulkan/VkDescriptorSetLayout.cpp",
        "patchSetId": 2
      },
      "lineNbr": 139,
      "author": {
        "id": 5050
      },
      "writtenOn": "2022-02-16T13:42:17Z",
      "side": 1,
      "message": "Ok, I can make that change. One question: what happens with robustness? Do we simply allow OOB reads to happen for uniform block descriptors? That doesn\u0027t seem correct to me, but if that\u0027s what we want, I can do it.",
      "parentUuid": "88b4e405_ef9c8b91",
      "range": {
        "startLine": 139,
        "startChar": 6,
        "endLine": 139,
        "endChar": 45
      },
      "revId": "5d04ea20e3e44365a6f753361f0596b68c0cff1e",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    }
  ]
}