{
  "comments": [
    {
      "key": {
        "uuid": "121cde6d_a13d7a7d",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-11T08:57:26Z",
      "side": 1,
      "message": "nit: I\u0027m not these the function names really make sense any more - it seems illogical for isInBounds() to return true for an OOB pointer.\n\nI\u0027m not great at naming things, but how about? \n\n  isInBounds() -\u003e accessMask()\n  isStaticAllInBounds() -\u003e needsAccessMasking()",
      "range": {
        "startLine": 171,
        "startChar": 15,
        "endLine": 171,
        "endChar": 34
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "27772b37_b6f197f6",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-07-11T20:26:28Z",
      "side": 1,
      "message": "The spec states that when the robustBufferAccess is disabled, \"applications *must* not perform out of bounds accesses\". Therefore we know these accesses to be in bounds. They could be OOB if the application made a mistake, but we\u0027re allowed to ignore that possibility to enable these optimizations. So isInBounds() still makes sense.\n\nI\u0027ll rename to isStaticAllInBounds() to isStaticallyInBounds(), to make the subtle distinction that the limit isn\u0027t necessarily static but we know through static analysis (and the app\u0027s provided guarantees) that the access must be in bounds.",
      "parentUuid": "121cde6d_a13d7a7d",
      "range": {
        "startLine": 171,
        "startChar": 15,
        "endLine": 171,
        "endChar": 34
      },
      "tag": "autogenerated:gerrit:newWipPatchSet",
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d5506c3d_cf55b3aa",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-12T00:21:00Z",
      "side": 1,
      "message": "I\u0027m still not convinced on the naming of this two functions.\n\n\u003e The spec states that when the robustBufferAccess is disabled, \"applications *must* not perform out of bounds accesses\".\n\nSure, but it seems we\u0027re conflating a function that tests for whether a pointer is in bounds with whether it is legal to access that address. \n\nThe name isStaticAllInBounds() / isStaticallyInBounds() seems like the function answers the question \"is the pointer known to be in bounds at compile time?\" (i.e. the original impl)\n\nGiven that the function now takes a \u0027OutOfBoundsBehavior\u0027 parameter, it certainly seems like this function is answering the question \"is it legal to perform an access on this pointer given the address and OOB rules\"? Hence the suggestion of renaming to focus on the access-is-legal aspect of things.",
      "parentUuid": "27772b37_b6f197f6",
      "range": {
        "startLine": 171,
        "startChar": 15,
        "endLine": 171,
        "endChar": 34
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "203f3139_26165f1c",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-07-18T20:07:57Z",
      "side": 1,
      "message": "If I\u0027m interpreting this correctly, your concern would be that an application may disable robustBufferAccess, do an out-of-bounds access that we *could* statically detect, and yet this function would return that it is within bounds?\n\nI don\u0027t think such case matters. The spec states the app *must* not do this, or it will face undefined behavior.\n\nJust to be clear, I don\u0027t think the distinction matters - when it comes to naming things. What this function really tries to answer is \"should we do bounds checking\"?\nI do care about SwiftShader actually detecting when the app violates the requirements, as a debugging feature. I\u0027ll definitely follow up on this.",
      "parentUuid": "d5506c3d_cf55b3aa",
      "range": {
        "startLine": 171,
        "startChar": 15,
        "endLine": 171,
        "endChar": 34
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2ddcaa7f_dc293682",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-18T21:48:09Z",
      "side": 1,
      "message": "\u003e If I\u0027m interpreting this correctly, your concern would be that an application may disable robustBufferAccess, do an out-of-bounds access that we *could* statically detect, and yet this function would return that it is within bounds?\n\nYes.\n\n\u003e I don\u0027t think such case matters. The spec states the app *must* not do this, or it will face undefined behavior.\n\nI just don\u0027t like a function called \u0027isStaticAllInBounds\u0027 to do anything other than telling you whether you are in bounds.\nBeing in-bounds was well defined - it\u0027s an address between SIMD::Pointer::base and SIMD::Pointer::base+SIMD::Pointer::limit()-1. I feel we\u0027re pointlessly muddying this definition for the sake of a function rename (or keeping this as-is and adding another, better named function).\n\nIt\u0027s like having a function called \u0027isThisAFish\u0027 that also takes a \u0027IfNotAFish\u0027 parameter and will also sometimes return true for Crustaceans. If you want to write a function that tests whether something is food for a penguin, name it \u0027isPenguinFood\u0027.\n\nGiven that we\u0027ve talked about pushing SIMD::Pointer down into Reactor, it also seems like a bad move to start pushing Vulkan concepts directly into it.",
      "parentUuid": "203f3139_26165f1c",
      "range": {
        "startLine": 171,
        "startChar": 15,
        "endLine": 171,
        "endChar": 34
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8de0f1dd_f471d249",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 171,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-07-19T14:20:34Z",
      "side": 1,
      "message": "\u003e It\u0027s like having a function called \u0027isThisAFish\u0027 that also takes a \u0027IfNotAFish\u0027 parameter and will also sometimes return true for Crustaceans.\n\nI think it\u0027s more like an \u0027isThisAFish\u0027 function which takes an \u0027itIsAFish\u0027 parameter which by contract requires it to be a fish. There\u0027s nothing sinister about the function returning true in that case if the user fails to pass in a fish. Loads of API functions don\u0027t do what their name implies if you use them incorrectly, even if they had all the information to do it, for the sake of performance.\n\nThat\u0027s essentially why assert() exists, and I\u0027ll implement such debug mode checks as part of b/137889774",
      "parentUuid": "2ddcaa7f_dc293682",
      "range": {
        "startLine": 171,
        "startChar": 15,
        "endLine": 171,
        "endChar": 34
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3ae446ef_bfa42918",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 184,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-11T08:57:26Z",
      "side": 1,
      "message": "Given that all bets are off with OutOfBoundsBehavior::UndefinedBehavior, why doesn\u0027t this function *always* return true if robust \u003d\u003d OutOfBoundsBehavior::UndefinedBehavior?",
      "range": {
        "startLine": 184,
        "startChar": 11,
        "endLine": 184,
        "endChar": 49
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4eb9052e_64a7dbfd",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 184,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-07-11T20:26:28Z",
      "side": 1,
      "message": "When the app disables robustBufferAccess it only has to guarantee that accesses in active SIMD lanes are within bounds. We need the offsets to be equal or sequential to know they\u0027ll also be in bounds for the inactive ones.",
      "parentUuid": "3ae446ef_bfa42918",
      "range": {
        "startLine": 184,
        "startChar": 11,
        "endLine": 184,
        "endChar": 49
      },
      "tag": "autogenerated:gerrit:newWipPatchSet",
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b35bbbed_342f9e12",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 184,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-12T00:21:00Z",
      "side": 1,
      "message": "I\u0027m going to have to come back to this - this has reached a level of complexity my brain cannot cope with tonight. Another attempt at explaining this might help.",
      "parentUuid": "4eb9052e_64a7dbfd",
      "range": {
        "startLine": 184,
        "startChar": 11,
        "endLine": 184,
        "endChar": 49
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "603076cc_a9901040",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 184,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-07-18T20:07:57Z",
      "side": 1,
      "message": "I had to sort my thoughts as well. Hopefully my last e-mail helped you too. I do think my conclusion on your question here is correct, but for the case where none of the execution lanes are active we could end up accessing out of bounds.\n\nGiven that the tests don\u0027t exercise that case, and it is presumably rare in practice, I\u0027d like to land this as-is to obtain the test speed gains, and make it my top priority to follow up with a fix for the edge cases (and provide tests).",
      "parentUuid": "b35bbbed_342f9e12",
      "range": {
        "startLine": 184,
        "startChar": 11,
        "endLine": 184,
        "endChar": 49
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "06fbbeed_5fb030d8",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 184,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-18T21:48:09Z",
      "side": 1,
      "message": "Heh. I came to the conclusion last night that this was free from OOB reads (I thought it just the writes that could cause issues).\n\nHowever, now that you\u0027ve said this, and I\u0027ve gone through this for the 4th time, I think I see what you mean. Arbitrary memory loads are quite scary.\n\n\u003e Given that the tests don\u0027t exercise that case, and it is presumably rare in practice, I\u0027d like to land this as-is to obtain the test speed gains, and make it my top priority to follow up with a fix for the edge cases (and provide tests).\n\nHumm... okay. This is your call. Do we have a bug tracker for this?",
      "parentUuid": "603076cc_a9901040",
      "range": {
        "startLine": 184,
        "startChar": 11,
        "endLine": 184,
        "endChar": 49
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1de699c8_5c8312e8",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 184,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-07-19T14:20:34Z",
      "side": 1,
      "message": "Yep, I don\u0027t feel great about breaking spec-compliant behavior, but I\u0027ll fix it ASAP:\nb/137896828 b/137890408 b/137889966 b/137889774",
      "parentUuid": "06fbbeed_5fb030d8",
      "range": {
        "startLine": 184,
        "startChar": 11,
        "endLine": 184,
        "endChar": 49
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e595041_055c3432",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 279,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-11T08:57:26Z",
      "side": 1,
      "message": "Good spot on the line above. This comment is equally broken.\n\n  // True if any dynamicOffsets are non-zero.",
      "range": {
        "startLine": 279,
        "startChar": 38,
        "endLine": 279,
        "endChar": 65
      },
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ab3ce4c_b6203c31",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 4
      },
      "lineNbr": 279,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-07-11T20:26:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6e595041_055c3432",
      "range": {
        "startLine": 279,
        "startChar": 38,
        "endLine": 279,
        "endChar": 65
      },
      "tag": "autogenerated:gerrit:newWipPatchSet",
      "revId": "93c38ab7f41a1d3e1352cf639020e6723c453faa",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}