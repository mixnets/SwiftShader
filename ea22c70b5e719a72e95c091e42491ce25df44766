{
  "comments": [
    {
      "key": {
        "uuid": "2f8ee9b6_d67b7be7",
        "filename": "src/Reactor/LLVMReactorDebugInfo.cpp",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 9669
      },
      "writtenOn": "2019-05-23T13:56:35Z",
      "side": 1,
      "message": "You needed to add this destructor because of forward-declaring the type used by the unique_ptr, right? In any case, I recommend the more modern approach to defining the destructor here:\n\nDebugInfo::~DebugInfo() \u003d default;\n\nThe defaulted form means the type is_trivially_destructible, which could be useful in some cases. Regardless, I like it because it helps enforce the fact that we shouldn\u0027t write destructors at all, and rely on RAII types instead.\n\nMore info: https://stackoverflow.com/a/27762244",
      "revId": "ea22c70b5e719a72e95c091e42491ce25df44766",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a74fc28b_4035a449",
        "filename": "src/Reactor/LLVMReactorDebugInfo.cpp",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-05-23T14:01:52Z",
      "side": 1,
      "message": "I haven\u0027t actually seen \u0027\u003d default\u0027 used outside of a header before. Done.",
      "parentUuid": "2f8ee9b6_d67b7be7",
      "revId": "ea22c70b5e719a72e95c091e42491ce25df44766",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d830357d_211a35ed",
        "filename": "src/Reactor/LLVMReactorDebugInfo.cpp",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-05-26T02:17:20Z",
      "side": 1,
      "message": "Would the compiler be more likely to inline the destructor when declared default in the declaration?",
      "parentUuid": "a74fc28b_4035a449",
      "revId": "ea22c70b5e719a72e95c091e42491ce25df44766",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "73bd3f40_9acb5470",
        "filename": "src/Reactor/LLVMReactorDebugInfo.cpp",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 9669
      },
      "writtenOn": "2019-05-26T12:56:08Z",
      "side": 1,
      "message": "Yes; however, that\u0027s not the issue here. When a class A has a unique_ptr\u003cB\u003e data member, and B is forward declared, A\u0027s destructor must have access to B\u0027s complete type. This is because unique_ptr\u0027s destructor invokes the deleter, which tries to delete B, and deleting an incomplete type is undefined behaviour. Incidentally, A\u0027s constructor _also_ needs to know B\u0027s full type for unique_ptr\u0027s constructor. So basically you must define both constructor and destructor in the cpp file, where you\u0027ve presumably included B.h.\n\nFor a deeper explanation, check out Howard Hinnant\u0027s explanation here: https://stackoverflow.com/a/6089065",
      "parentUuid": "d830357d_211a35ed",
      "revId": "ea22c70b5e719a72e95c091e42491ce25df44766",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "448eb4c2_c9638bfc",
        "filename": "src/Reactor/LLVMReactorDebugInfo.cpp",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-05-28T18:12:19Z",
      "side": 1,
      "message": "Absolutely, I wasn\u0027t questioning why we need the destructor definition nor using the default implementation. Just seems more common to do it in the header, which helps to clarify that the destructor is not intended to have side-effects other than the default, and can lead to it being inlined.\n\nI guess my question is, what\u0027s the benefit of defining a default destructor in the source file? Maybe if it\u0027s expected to be very big and called in multiple places it helps prevent inlining?\n\nLGTM either way.",
      "parentUuid": "73bd3f40_9acb5470",
      "revId": "ea22c70b5e719a72e95c091e42491ce25df44766",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a5ff1c25_d9addb52",
        "filename": "src/Reactor/LLVMReactorDebugInfo.cpp",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-05-28T18:31:31Z",
      "side": 1,
      "message": "\u003e what\u0027s the benefit of defining a default destructor in the source file? \n\nGiven that you seem to understand the reasons why the implementation (hand-crafted or via a default) must be in the .cpp file, are you specifically asking what\u0027s the benefit of using:\n\n  DebugInfo::~DebugInfo() \u003d default;\n\ninstead of\n\n  DebugInfo::~DebugInfo() {}\n\nin a .cpp source file? I just want to be sure I understand your question properly here. If that is the question, I guess Antonio\u0027s original statement stands of regardless of where (.hpp or .cpp) you put the \u0027\u003d default\u0027:\n\n  \"I like it because it helps enforce the fact that we shouldn\u0027t write destructors at all, and rely on RAII types instead.\"\n\n\u003e Maybe if it\u0027s expected to be very big and called in multiple places it helps prevent inlining?\n\nEach compilation unit has no visibility into another\u0027s implementation of a destructor via \u0027\u003d default\u0027 or a hand-rolled impl (nor any other regular function). So ignoring any sort of link time optimization, there would be no possibility of inlining a destructor implemented in another .cpp file.",
      "parentUuid": "448eb4c2_c9638bfc",
      "revId": "ea22c70b5e719a72e95c091e42491ce25df44766",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}