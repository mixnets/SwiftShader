{
  "comments": [
    {
      "key": {
        "uuid": "e1236df4_b4b475ad",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-05-09T20:06:08Z",
      "side": 1,
      "message": "Reactor has its own mutex (until we make it thread safe). We just need to be careful about race conditions now. We could be querying the cache, notice a routine is missing, generate one, and then find that the cache does contain an entry for it that was generated by another thread.\n\nCould you check if that\u0027s safe? And what about when the other thread is currently executing a routine that is going to get evicted from the cache? We reference count the renderer ones but I\u0027m not sure about the blitter.",
      "range": {
        "startLine": 10,
        "startChar": 12,
        "endLine": 10,
        "endChar": 66
      },
      "revId": "57d55b98bf7bd42e84c3340d6b3e8388d7af1cea",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "811cf000_f6a5bcb1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-05-13T20:51:15Z",
      "side": 1,
      "message": "\u003e We could be querying the cache, notice a routine is missing, generate one, and then find that the cache does contain an entry for it that was generated by another thread.\n\nYes. I typically solve this with something like:\n\n    Value LazyBuiltCache::getOrBuild(Key key)\n    {\n        mutex.lock();\n        auto it \u003d map.find(key);\n        if (it \u003d\u003d mapMutex.end())\n        {\n            auto entry \u003d new Entry();\n            map.emplace(key, entry);\n            mutex.unlock();\n\n            entry-\u003ebuild(); // The thing that takes a long time.\n            entry-\u003eready.signal(); // inform other threads that the value is built.\n            return entry-\u003evalue;\n        }\n        else\n        {\n            auto entry \u003d it-\u003esecond;\n            mutex.unlock();\n\n            entry-\u003eready.wait(); // wait for value to be ready.\n            return entry-\u003evalue;\n        }\n    }",
      "parentUuid": "e1236df4_b4b475ad",
      "range": {
        "startLine": 10,
        "startChar": 12,
        "endLine": 10,
        "endChar": 66
      },
      "revId": "57d55b98bf7bd42e84c3340d6b3e8388d7af1cea",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95f5a789_3041c168",
        "filename": "src/Device/Blitter.hpp",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-05-09T20:06:08Z",
      "side": 1,
      "message": "mutex",
      "range": {
        "startLine": 153,
        "startChar": 44,
        "endLine": 153,
        "endChar": 53
      },
      "revId": "57d55b98bf7bd42e84c3340d6b3e8388d7af1cea",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ded22c2_cf20b471",
        "filename": "src/Device/Blitter.hpp",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 5050
      },
      "writtenOn": "2019-05-29T14:38:47Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "95f5a789_3041c168",
      "range": {
        "startLine": 153,
        "startChar": 44,
        "endLine": 153,
        "endChar": 53
      },
      "revId": "57d55b98bf7bd42e84c3340d6b3e8388d7af1cea",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}