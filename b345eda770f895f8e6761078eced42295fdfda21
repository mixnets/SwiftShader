{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "658860d0_c58e7b13",
        "filename": "src/Reactor/ExecutableMemory.cpp",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-12-04T15:38:58Z",
      "side": 0,
      "message": "Is replacing anonymous scopes with \u0027static\u0027 functions a personal preference? Anonymous namespaces are superior and generally preferred as they allow you to make things like class definitions and enums anonymous, while \"static\" can only be applied to functions and global variables.",
      "revId": "b345eda770f895f8e6761078eced42295fdfda21",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "efbf2a36_4a82e443",
        "filename": "src/Reactor/ExecutableMemory.cpp",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-04T16:23:52Z",
      "side": 0,
      "message": "The C++ spec standard, which initially stated that anonymous namespaces are superior and this use of static is deprecated, dropped that entire paragraph...\n\nThere are several reasons why I think static is preferable:\n- I can immediately see the linkage of the function. I don\u0027t have to check whether or not there\u0027s an anonymous namespace somewhere and whether this function is inside or outside of it.\n- I can move the function around in the file, without risk of pulling it in or out of an anonymous namespace.\n- The anonymous namespace semantics are not what I would call obvious. At a cursory glance it looks like something redundant. I\u0027d rather have the use of the namespace keyword actually introduce a namespace.\n- The fact that an anonymous namespace can make types invisible to other compile units doesn\u0027t seem like a material advantage to me. Named namespaces already serve the purpose of keeping identically named objects apart, but it should still be done sparingly to avoid confusion. Anonymous namespaces can lead to a lot of things being called the same.\n- Anonymous namespaces in headers are a recipe for disaster since each translation unit will get its own definition.\n\nThat said, I can remove this refactoring from this patch if you think it warrants a longer discussion before settling on a guideline.",
      "parentUuid": "658860d0_c58e7b13",
      "revId": "b345eda770f895f8e6761078eced42295fdfda21",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3aaf19be_6a97170f",
        "filename": "src/Reactor/ExecutableMemory.cpp",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-12-04T17:32:33Z",
      "side": 0,
      "message": "\u003e The C++ spec standard, which initially stated that anonymous namespaces are superior and this use of static is deprecated, dropped that entire paragraph...\n\nI\u0027m not sure what you\u0027re referring to here. I don\u0027t recall any mention of \u0027static\u0027 being deprecated. Anonymous namespaces are strictly superior in that they do everything static can do, and more. To be clear, I meant superior in terms of functionality, not readability or anything else.\n\n\u003e I can immediately see the linkage of the function. I don\u0027t have to check whether or not there\u0027s an anonymous namespace somewhere and whether this function is inside or outside of it.\n\nAgreed, this is an advantage of \u0027static\u0027 for sure.\n\n\u003e The anonymous namespace semantics are not what I would call obvious. At a cursory glance it looks like something redundant. I\u0027d rather have the use of the namespace keyword actually introduce a namespace.\n\nWhile it\u0027s true that the semantics seem irregular, like every feature of C++, it\u0027s one that we all have to learn. The idea behind it, though, makes sense to me: if you can\u0027t name the scope, then it\u0027s only visible to code that\u0027s in scope (in this case, the code below it in the file). This is a lot like \"Voldermort types\".\n\n\u003e The fact that an anonymous namespace can make types invisible to other compile units doesn\u0027t seem like a material advantage to me. Named namespaces already serve the purpose of keeping identically named objects apart, but it should still be done sparingly to avoid confusion. Anonymous namespaces can lead to a lot of things being called the same.\n\nOne advantage of hiding symbols is faster linking. The other is the ability to name symbols the same way, which can be an advantage in certain cases. In any case, your argument here against anonymous namespaces are the same against using static - that they can lead to a lot of things being named the same.\n\n\u003e Anonymous namespaces in headers are a recipe for disaster since each translation unit will get its own definition.\n\nAlso true about static, so not really specific to anonymous namespaces.\n\n\u003e That said, I can remove this refactoring from this patch if you think it warrants a longer discussion before settling on a guideline.\n\nI agree that seeing the keyword \u0027static\u0027 on a function makes it immediately clear that it\u0027s internal linkage. But the fact that I can\u0027t use it for classes and enums means that we\u0027re forced to mix using anoynmous namespaces and static. I prefer to just use one way and be consistent. Now having said that, we could actually have our cake and eat it too: nothing stops us from putting \u0027static\u0027 on functions/globals in anonymous namespaces. It\u0027s redundant, but perhaps a good compromise?\n\nNow having said all that, I\u0027m not going to fight this one. You can make the final call as the TL.",
      "parentUuid": "efbf2a36_4a82e443",
      "revId": "b345eda770f895f8e6761078eced42295fdfda21",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a1232492_bf591f48",
        "filename": "src/Reactor/ExecutableMemory.cpp",
        "patchSetId": 1
      },
      "lineNbr": 46,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-12-04T20:04:35Z",
      "side": 0,
      "message": "\u003e I\u0027m not sure what you\u0027re referring to here.\n\nhttps://stackoverflow.com/questions/4726570/deprecation-of-the-static-keyword-no-more\n\n\u003e Anonymous namespaces are strictly superior in that they do everything static can do, and more. To be clear, I meant superior in terms of functionality, not readability or anything else.\n\nUnderstood, but I think it\u0027s a bit contentious to use the word \"superior\" in such a way. I mean, assembly is strictly superior to any language from a functionality point of view (when we discount abstraction as functionality and purely look at what can be achieved with it). My point is, readability should very much factor into when and where a feature is used, in my opinion.\n\n\u003e While it\u0027s true that the semantics seem irregular, like every feature of C++, it\u0027s one that we all have to learn.\n\nI\u0027m not arguing that we shouldn\u0027t have to learn it (by avoiding it). Even the worst features should be understood, because they could be used somewhere (comma operator semantics is one of my favorites, but it\u0027s put to good use in Reactor\u0027s control flow macros). But we can at least minimize the use of some of the less intuitive features to improve readability and reduce cognitive load, allowing more focus on the things that matter most.\n\n\u003e The idea behind it, though, makes sense to me: if you can\u0027t name the scope, then it\u0027s only visible to code that\u0027s in scope (in this case, the code below it in the file).\n\nThis is how I reason about it as well, but it takes effort. \u0027static\u0027, while far from perfect, is less strained in my opinion (and again, has far more localized effect which also keeps things easier to parse).\n\n\u003e This is a lot like \"Voldermort types\".\n\nTIL. I don\u0027t think it\u0027s intuitive at all though that an anonymous namespace works like an inline namespace. Voldemort types don\u0027t have that bleeding things out of the scope issue and I find it intuitive to read (less intuitive to write, though, but one would obviously only ever use it when there\u0027s a strong advantage like frequently changing names or complex templates types).\n\n\u003e One advantage of hiding symbols is faster linking.\n\nTrue, if a lot of types are defined in the anonymous namespace, it wins out over not having one. I don\u0027t mean to put a ban on them or anything. That said, I\u0027m not sure this has much of an effect in practice. A bit of measurement could be useful before recommending them for this reason, and compile/link speed seldom seems like it should take precedence over readability.\n\n\u003e In any case, your argument here against anonymous namespaces are the same against using static - that they can lead to a lot of things being named the same.\n\nTrue, static can be abused the same way for giving the same name to a function. It doesn\u0027t for types though, and I think it\u0027s arguable that two functions with the same name might not lower readability if it\u0027s clear from the arguments being passed in what will happen (i.e. the same justification for function/method overloading usually not causing much confusion), whereas types with the same name, and within the same namespace, are more troublesome.\n\n\u003e Also true about static, so not really specific to anonymous namespaces.\n\nSure, but I think being a specifier that has to be repeated for every declaration helps, versus the scope-based altering of semantics of anonymous namespaces.\n\n\u003e But the fact that I can\u0027t use it for classes and enums means that we\u0027re forced to mix using anoynmous namespaces and static.\n\nWhat do you mean by \"forced\"? C++ would be just fine without anonymous namespaces.\n\n\u003e I prefer to just use one way and be consistent. Now having said that, we could actually have our cake and eat it too: nothing stops us from putting \u0027static\u0027 on functions/globals in anonymous namespaces. It\u0027s redundant, but perhaps a good compromise?\n\nInteresting suggestion, and certainly a compromise in some ways, but it also suffers from the issue that if one or the other is removed, you\u0027d still get internal linking even if you were aiming for external linkage.\n\n\u003e Now having said all that, I\u0027m not going to fight this one. You can make the final call as the TL.\n\nNo, I care about reaching consensus about these things, or at least understanding the full scope of reasoning behind it (for both). I shouldn\u0027t have assumed it was going to be unchallenged to sneak this in. 8-)\n\nI removed replacing the anonymous namespace with uses of static so this can land before we\u0027re done discussing.",
      "parentUuid": "3aaf19be_6a97170f",
      "revId": "b345eda770f895f8e6761078eced42295fdfda21",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4"
    }
  ]
}