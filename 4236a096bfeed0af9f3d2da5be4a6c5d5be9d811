{
  "comments": [
    {
      "key": {
        "uuid": "c778d11c_1a901a2f",
        "filename": "src/Renderer/Blitter.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1108,
      "author": {
        "id": 5005
      },
      "writtenOn": "2017-12-21T19:54:34Z",
      "side": 1,
      "message": "I think this can just be srcSRGB || dstSRGB now. Obviously when neither is sRGB we don\u0027t take this path, but when both are then reverseConversion is true and we take this path.",
      "range": {
        "startLine": 1108,
        "startChar": 26,
        "endLine": 1108,
        "endChar": 94
      },
      "revId": "4236a096bfeed0af9f3d2da5be4a6c5d5be9d811",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5fe176c5_d0ea3a29",
        "filename": "src/Renderer/Blitter.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1108,
      "author": {
        "id": 5050
      },
      "writtenOn": "2018-01-08T22:25:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c778d11c_1a901a2f",
      "range": {
        "startLine": 1108,
        "startChar": 26,
        "endLine": 1108,
        "endChar": 94
      },
      "revId": "4236a096bfeed0af9f3d2da5be4a6c5d5be9d811",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2fee404d_e0ab4ee1",
        "filename": "src/Renderer/Blitter.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1351,
      "author": {
        "id": 5005
      },
      "writtenOn": "2017-12-21T19:54:34Z",
      "side": 1,
      "message": "This still looks inversed to me. If the destination format is sRGB, but the source is not, then we shouldn\u0027t convert prior to filtering (i.e. we\u0027d be filtering in the sRGB domain, which is wrong).",
      "range": {
        "startLine": 1351,
        "startChar": 7,
        "endLine": 1351,
        "endChar": 84
      },
      "revId": "4236a096bfeed0af9f3d2da5be4a6c5d5be9d811",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3cfbc921_9827e5c4",
        "filename": "src/Renderer/Blitter.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1351,
      "author": {
        "id": 5050
      },
      "writtenOn": "2018-01-08T22:25:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2fee404d_e0ab4ee1",
      "range": {
        "startLine": 1351,
        "startChar": 7,
        "endLine": 1351,
        "endChar": 84
      },
      "revId": "4236a096bfeed0af9f3d2da5be4a6c5d5be9d811",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f50ae1f3_5d52b87e",
        "filename": "src/Renderer/Blitter.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1352,
      "author": {
        "id": 5005
      },
      "writtenOn": "2017-12-21T19:54:34Z",
      "side": 1,
      "message": "This is a confusing name. I think we need to discern three situations:\n- Call ApplyScaleAndClamp only before filtering.\n- Call it both before and after filtering.\n- Call it only after filtering.\n\nSo this could be done with a preConversion and postConversion boolean. In theory a preConversion and splitConversion would also work (i.e. !pre \u0026\u0026 split implies post), but that\u0027s likely less elegant.",
      "range": {
        "startLine": 1352,
        "startChar": 7,
        "endLine": 1352,
        "endChar": 24
      },
      "revId": "4236a096bfeed0af9f3d2da5be4a6c5d5be9d811",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b36df5d3_f5171fed",
        "filename": "src/Renderer/Blitter.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1352,
      "author": {
        "id": 5050
      },
      "writtenOn": "2018-01-08T22:25:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f50ae1f3_5d52b87e",
      "range": {
        "startLine": 1352,
        "startChar": 7,
        "endLine": 1352,
        "endChar": 24
      },
      "revId": "4236a096bfeed0af9f3d2da5be4a6c5d5be9d811",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d3479996_1ca36114",
        "filename": "src/Renderer/Blitter.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1370,
      "author": {
        "id": 5005
      },
      "writtenOn": "2017-12-21T19:54:34Z",
      "side": 1,
      "message": "This can always be true, which then just becomes an indication for the ApplyScaleAndClamp() function whether it\u0027s before or after filtering.",
      "range": {
        "startLine": 1370,
        "startChar": 84,
        "endLine": 1370,
        "endChar": 101
      },
      "revId": "4236a096bfeed0af9f3d2da5be4a6c5d5be9d811",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a270ac40_0628ddf8",
        "filename": "src/Renderer/Blitter.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1370,
      "author": {
        "id": 5050
      },
      "writtenOn": "2018-01-08T22:25:08Z",
      "side": 1,
      "message": "This needs to know if the scaling was already performed in order to properly unscale, if required, so I this this requires knowledge of whether or not scaling was already performed.",
      "parentUuid": "d3479996_1ca36114",
      "range": {
        "startLine": 1370,
        "startChar": 84,
        "endLine": 1370,
        "endChar": 101
      },
      "revId": "4236a096bfeed0af9f3d2da5be4a6c5d5be9d811",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cdfe7eb3_edb5d2a4",
        "filename": "src/Renderer/Blitter.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1370,
      "author": {
        "id": 5005
      },
      "writtenOn": "2018-01-09T18:16:05Z",
      "side": 1,
      "message": "Not really. Note that in PS4, preScaled is set to true if (state.convertSRGB \u0026\u0026 Surface::isSRGBformat(state.sourceFormat)), and it\u0027s not used before that point. In other words you could directly initialize it to that. Furthermore, it\u0027s entirely computed from \u0027state\u0027, which is also available in ApplyScaleAndClamp(), so preScaled doesn\u0027t even have to be passed in as a parameter. The only information it doesn\u0027t have is whether it\u0027s being called before or after the filtering.\n\nI still think the code would look slightly simpler if you just move all the conditional logic to ApplyScaleAndClamp().\n\nAnother way to think about it is that there could be an ApplyScaleAndClampBeforeFiltering() and ApplyScaleAndClampAfterFiltering(), except they would have a lot of duplicate code. Either that could be factored out into more helper functions, or, we just pass the Before/After as a parameter to ApplyScaleAndClamp(). I think the latter would be most elegant.",
      "parentUuid": "a270ac40_0628ddf8",
      "range": {
        "startLine": 1370,
        "startChar": 84,
        "endLine": 1370,
        "endChar": 101
      },
      "revId": "4236a096bfeed0af9f3d2da5be4a6c5d5be9d811",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}