{
  "comments": [
    {
      "key": {
        "uuid": "0f040192_f8bf6780",
        "filename": "src/Vulkan/VkPipeline.cpp",
        "patchSetId": 7
      },
      "lineNbr": 500,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-06-28T17:14:29Z",
      "side": 1,
      "message": "nit: UNSUPPORTED",
      "range": {
        "startLine": 500,
        "startChar": 2,
        "endLine": 500,
        "endChar": 15
      },
      "revId": "2b43bf9aeecbff5b81823f7a10de4c27fd36af2b",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fd9a2d5a_79de80d3",
        "filename": "src/Vulkan/VkPipeline.cpp",
        "patchSetId": 7
      },
      "lineNbr": 518,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-06-28T17:14:29Z",
      "side": 1,
      "message": "nit: It\u0027s a bit confusing to be setting up a \u0027key\u0027 even if no pipeline cache is present. Gathering everything that affects shader compilation into an object is valuable though for many other reasons like debugging and perhaps an on-disk cache in the future. So no objections there.\n\nI think we should consider renaming SpirvShaderKey to something ending in \u0027State\u0027. It\u0027s a detail, though an important one, that it\u0027s also used as the key for the cache.\n\nWe should also look into the interaction with our Reactor Routine caches. We still recompile all the SPIR-V as part of a vertex or pixel routine if any fixed-function state changed. So this pipeline cache implementation appears to mainly just avoid calling preprocessSpirv() over and over on the same SPIR-V?\n\nCan all be looked into post-Pastel.",
      "range": {
        "startLine": 515,
        "startChar": 2,
        "endLine": 518,
        "endChar": 20
      },
      "revId": "2b43bf9aeecbff5b81823f7a10de4c27fd36af2b",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "773508a8_95f5ceb6",
        "filename": "src/Vulkan/VkPipelineCache.cpp",
        "patchSetId": 7
      },
      "lineNbr": 26,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-06-28T17:14:29Z",
      "side": 1,
      "message": "nit: To avoid allocations outside of the vkCreate* calls I think we should leave the specialization data stored as part of the pipeline object.\n\nThe other members of this class are also just copies of the pipeline\u0027s creation data. So perhaps this should just contain a pointer to the pipeline object, and a hash of its state for quick comparison.\n\nCan be refactored later.",
      "range": {
        "startLine": 26,
        "startChar": 3,
        "endLine": 26,
        "endChar": 11
      },
      "revId": "2b43bf9aeecbff5b81823f7a10de4c27fd36af2b",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "666890a5_83505e5a",
        "filename": "src/Vulkan/VkPipelineCache.hpp",
        "patchSetId": 7
      },
      "lineNbr": 69,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-06-28T17:14:29Z",
      "side": 1,
      "message": "nit: We don\u0027t currently specialize based on subpass. This is where the gain realized by https://swiftshader-review.googlesource.com/c/SwiftShader/+/33109 came from.\n\nSo it looks like we\u0027re still calling preprocessSpirv() too many times for pipelines that only differ by subpass index. We should just delete it from this key/state.\n\nCan be done later.",
      "range": {
        "startLine": 69,
        "startChar": 32,
        "endLine": 69,
        "endChar": 44
      },
      "revId": "2b43bf9aeecbff5b81823f7a10de4c27fd36af2b",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "18b3153b_e8857517",
        "filename": "src/Vulkan/VkPipelineCache.hpp",
        "patchSetId": 7
      },
      "lineNbr": 131,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-06-28T17:14:29Z",
      "side": 1,
      "message": "nit: Would probably be faster to use an unordered_map for these. It can do the lookup based on a hash computed once from this large amount of state, instead of potentially doing lots of comparisons on nearly-equal data.\n\nFor later.",
      "range": {
        "startLine": 131,
        "startChar": 6,
        "endLine": 131,
        "endChar": 9
      },
      "revId": "2b43bf9aeecbff5b81823f7a10de4c27fd36af2b",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}