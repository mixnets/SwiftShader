{
  "comments": [
    {
      "key": {
        "uuid": "54d319d7_79a95d48",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 34
      },
      "lineNbr": 1176,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-01-09T16:09:49Z",
      "side": 1,
      "message": "Can these be moved into some kind of object/interface? At least that way dbgInit() and dbgTerm() can be the constructor and destructor to prevent doing things in the wrong sequence. Also it could talk to a more restricted interface into SprivShader, instead of having access to everything, which might eventually lead to more coupling than desired, and hence higher maintenance cost during refactorings.\n\nAntonio and I had an interesting chat the other day: he has two different experiences writing debuggers for emulator\u0027s chips, and mentioned a more event-driven design option too. I think the both of you should talk about the pros and cons of several design choices.\n\nAnyway, I\u0027m OK with this as-is for now since we need a working starting point first and will probably require some iteration and gaining insight into practical usage before we settle on a more abstracted design.",
      "range": {
        "startLine": 1176,
        "startChar": 13,
        "endLine": 1176,
        "endChar": 26
      },
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a3979d6c_1b24a213",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 34
      },
      "lineNbr": 1176,
      "author": {
        "id": 7183
      },
      "writtenOn": "2020-01-09T16:18:26Z",
      "side": 1,
      "message": "\u003e Can these be moved into some kind of object/interface?\n\nYes, I guess so. I\u0027d have to pass the SpirvShader down into each of the functions.\nMind if this is done as a follow up change? Otherwise it\u0027s going to cause rebase hell with the WIP stuff.\n\n\u003e Antonio and I had an interesting chat the other day: he has two different experiences writing debuggers for emulator\u0027s chips, and mentioned a more event-driven design option too.\n\nYup, I\u0027m definitely open to changing the design here. This is a very explicit and slow implementation. I\u0027m certainly open to other approaches, but like you said, I\u0027d like to get something that works, get it tested, then optimize / refactor.",
      "parentUuid": "54d319d7_79a95d48",
      "range": {
        "startLine": 1176,
        "startChar": 13,
        "endLine": 1176,
        "endChar": 26
      },
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2686801a_f14aefbc",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 34
      },
      "lineNbr": 1176,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-01-10T08:31:13Z",
      "side": 1,
      "message": "ack",
      "parentUuid": "a3979d6c_1b24a213",
      "range": {
        "startLine": 1176,
        "startChar": 13,
        "endLine": 1176,
        "endChar": 26
      },
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b4ad005_a1c22228",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 34
      },
      "lineNbr": 1176,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-01-10T21:19:57Z",
      "side": 1,
      "message": "Let me just jot down some of the points I made when discussing with Nicolas, so that it\u0027s here:\n\nBasically, I wrote two emulators, each with its own debugger, and each with a different design:\n\n1. For the NES emulator, the Debugger knew about all the components, like the Cpu, and the Cpu knew about the Debugger, so that it could forward info to the Debuger (preExecuteOp, postExecuteOp, etc.).\n\n2. For the Vectrex emulator, my Debugger knew about all components, but components did not know about the Debugger. This made the design much simpler and easier to understand - all dependencies in one direction. However, it also meant that I had to duplicate some logic from, say, the Cpu to the Debugger, such as instruction decoding. The Cpu decodes to execute, the Debugger decodes to spit out the disassembled representation. I also had to expose more internals of the Cpu so that the Debugger could introspect its state.\n\nIn the end, I much preferred the 2nd option, despite a bit of copy pasting. However, there was a third option that I considered that is sort of in between 1 and 2: the Cpu provides hooks/callbacks for interesting events (pre/postExecuteOp), and the Debugger hooks into those. This makes the Cpu code similar to option 1, but at least it\u0027s dependent on some generic event thing, rather than directly on a Debugger. Furthermore, it means it\u0027s easy to hook other stuff, like a Stub implementation, or a Logger. Also, it allows to enable/disable the debugger more easily by registering/unregistering for the events at runtime, if that\u0027s useful.\n\nAll that to say, we may want to consider removing the concept of a debugger from SpirvShader, and add event hooks instead. The Debugger can hook in from the outside and get what it needs. Or, if possible, go with what I did in my Vectrex emulator (option 2 above), and have the Debugger introspect and figure out what it needs from SpirvShader, if that\u0027s possible.\n\nFood for thought ðŸ˜Š",
      "parentUuid": "2686801a_f14aefbc",
      "range": {
        "startLine": 1176,
        "startChar": 13,
        "endLine": 1176,
        "endChar": 26
      },
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ea266a68_f5399c2c",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 34
      },
      "lineNbr": 1176,
      "author": {
        "id": 7183
      },
      "writtenOn": "2020-01-10T23:58:48Z",
      "side": 1,
      "message": "\u003e All that to say, we may want to consider removing the concept of a debugger from SpirvShader, and add event hooks instead. \n\nThis is sort of what the SpirvShader::dbgXXX functions really are.\nThe functions are all one-way (SpirvShader::non-dbgXXX to dbgXXX), all implemented in a separate compilation unit, use pure private-impl state, and are all no-op if the debugger isn\u0027t active - the only real difference is, they\u0027re members of SpirvShader, not via some dynamic dispatch mechanism. The main reason for them being member functions is that the bulk of the compiler state is private to the SpirvShader class. Attempting to make the debugger logic external would require exposing a whole load of SpirvShader private data, and would be a huge increase in public surface area.\n\nIf we don\u0027t care about virtual call overhead, I\u0027m thinking I can address some of what your asking for, and what Nicolas was asking for:\n\n1) I move all the SpirvShader::dbgXXX functions to a new inner, pure virtual class (interface).\n2) SpirvShaderDebugger.cpp has an implementation of this interface, which also holds its internal debugger state as members.\n3) SpirvShader either constructs the real debugger interface implementation, or a dummy implementation which is pure-no-op, depending on whether the debugger is active.\n\nThis way, if you wanted to build yourself a logger implementation, we can reimplement this interface other ways. This interface could be considered as a SpirvShader generator \u0027plugin\u0027 - it has the ability to inject any sort of additional logic. We could also have a vector of these active at any time (say debugger + logger).\n\nAll of this seems reasonable to me, but I suspect some people might class this as over-engineering.",
      "parentUuid": "6b4ad005_a1c22228",
      "range": {
        "startLine": 1176,
        "startChar": 13,
        "endLine": 1176,
        "endChar": 26
      },
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09f60692_b387acee",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 34
      },
      "lineNbr": 34,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-01-10T21:19:57Z",
      "side": 1,
      "message": "I personally like to add \"extern\" to these functions, to communicate that this is a prototype for a function hidden inside another cpp file. Obviously it\u0027s not necessary, but I\u0027ve seen this done in many places, and it can be helpful. Also, have you considered reaching out to the SPIRV team about exposing this functionality?",
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "202317b9_776a8f0a",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 34
      },
      "lineNbr": 34,
      "author": {
        "id": 7183
      },
      "writtenOn": "2020-01-10T23:58:48Z",
      "side": 1,
      "message": "Done.\n\n\u003e Also, have you considered reaching out to the SPIRV team about exposing this functionality?\n\nYes. I\u0027ll raise this with my team.",
      "parentUuid": "09f60692_b387acee",
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "509feda1_9fe84cce",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 34
      },
      "lineNbr": 46,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-01-10T21:19:57Z",
      "side": 1,
      "message": "In C++17, we can use std::size() for arrays! Oh, and std::ssize in C++20 to get a signed ssize_t! What an exciting future!",
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38ae8255_4559456e",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 34
      },
      "lineNbr": 46,
      "author": {
        "id": 7183
      },
      "writtenOn": "2020-01-10T23:58:48Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "509feda1_9fe84cce",
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3e0018a2_615dfdd1",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 34
      },
      "lineNbr": 177,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-01-10T21:19:57Z",
      "side": 1,
      "message": "Consider passing in a reference to a State* so that you can also set it to nullptr after deleting. This way, the caller doesn\u0027t end up with a dangling pointer after the call.",
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "35d8af6c_fd59c8f1",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 34
      },
      "lineNbr": 210,
      "author": {
        "id": 9669
      },
      "writtenOn": "2020-01-10T21:19:57Z",
      "side": 1,
      "message": "I\u0027m guessing it\u0027s safe to call thread-\u003eexit() twice? Asking since this function is also called by the destructor.",
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8bdfb985_3a6a7808",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 34
      },
      "lineNbr": 210,
      "author": {
        "id": 7183
      },
      "writtenOn": "2020-01-10T23:58:48Z",
      "side": 1,
      "message": "It has to be symmetrical. The constructor calls enter().",
      "parentUuid": "35d8af6c_fd59c8f1",
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "14dd6fca_9ebc8fe0",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 34
      },
      "lineNbr": 485,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-01-09T16:09:49Z",
      "side": 1,
      "message": "Is there a more structural way to ensure all these debugger API calls are zero cost when no debugger is present?\n\nOK for now for the MVP.",
      "range": {
        "startLine": 484,
        "startChar": 0,
        "endLine": 485,
        "endChar": 21
      },
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9dec09f_5d2e4edb",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 34
      },
      "lineNbr": 485,
      "author": {
        "id": 7183
      },
      "writtenOn": "2020-01-09T16:18:26Z",
      "side": 1,
      "message": "Depends on whether you want to litter the call sites with conditionals or keep all this stuff in this file. I thought you\u0027d prefer the latter.",
      "parentUuid": "14dd6fca_9ebc8fe0",
      "range": {
        "startLine": 484,
        "startChar": 0,
        "endLine": 485,
        "endChar": 21
      },
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "976df2a1_9aad546b",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 34
      },
      "lineNbr": 485,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-01-10T08:31:13Z",
      "side": 1,
      "message": "How about using a proxy class which holds a pointer to the implementation class instance and just forwards the calls, unless the pointer is null. This way it\u0027s a clear, detectable error to have the SpirvShader calls into this have any effect when there\u0027s no debugger present.\n\nSince this depends on https://swiftshader-review.googlesource.com/c/SwiftShader/+/38915/34/src/Pipeline/SpirvShader.hpp#1176 let\u0027s revisit this after landing the MVP.",
      "parentUuid": "c9dec09f_5d2e4edb",
      "range": {
        "startLine": 484,
        "startChar": 0,
        "endLine": 485,
        "endChar": 21
      },
      "revId": "417309a918537205e3146f0502df53b2052adf72",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}