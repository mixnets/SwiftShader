{
  "comments": [
    {
      "key": {
        "uuid": "f7ab644e_509a41e5",
        "filename": "src/Pipeline/SpirvShader.cpp",
        "patchSetId": 3
      },
      "lineNbr": 290,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-11T08:43:24Z",
      "side": 1,
      "message": "nit: \"robust\" made sense as a bool, seems a little odd for a variable name of type OutOfBoundsBehavior (where RobustBufferAccess is one of the possible values).\n\nI know you\u0027re not particularly fond on acronyms, but \u0027OutOfBoundsBehavior oobb\u0027 seems like a more fitting name to me, with little room for confusion.",
      "range": {
        "startLine": 290,
        "startChar": 42,
        "endLine": 290,
        "endChar": 48
      },
      "revId": "013938b34ca13f0f7dd02d2f5548114dd51469a3",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "44742697_edbbc272",
        "filename": "src/Pipeline/SpirvShader.cpp",
        "patchSetId": 3
      },
      "lineNbr": 321,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-11T08:43:24Z",
      "side": 1,
      "message": "No action required: Nice place to put a JIT assert. :)",
      "range": {
        "startLine": 321,
        "startChar": 5,
        "endLine": 321,
        "endChar": 10
      },
      "revId": "013938b34ca13f0f7dd02d2f5548114dd51469a3",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "81bf0ab2_c2b0f8c9",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-11T08:43:24Z",
      "side": 1,
      "message": "Nitpicking here, but while reviewing this I did have to keep jumping back to the definitions here to really understand what they meant.\nMaking the enum names more descriptive may have helped. Suggestion:\n\n  enum class OutOfBoundsBehavior\n  {\n  \t// Loads are zeroed. Writes are elided.\n  \tReadsZeroedWritesElided,\n\n  \t// Load values are undefined. Writes are elided.\n  \t// Will not cause program termination.\n        ReadsUndefinedWritesElided,\n\n  \t// Loaded values can be anything.\n  \t// Writes may cause memory corruption or program termination.\n        ReadsUndefinedWritesUndefined\n  };",
      "range": {
        "startLine": 58,
        "startChar": 12,
        "endLine": 58,
        "endChar": 31
      },
      "revId": "013938b34ca13f0f7dd02d2f5548114dd51469a3",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3688f461_e938b3c7",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 3
      },
      "lineNbr": 61,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-11T08:43:24Z",
      "side": 1,
      "message": "Currently (and your other two CLs), RobustBufferAccess is always treated the same as Zero.\nI saw the TODO regarding the potential optimization, so I get why they\u0027re split.\nHowever, the documentation for Zero is a nice and succinct, where as RobustBufferAccess a homework exercise and doesn\u0027t actually state the behaviour of our particular implementation.\n\nTo make this enum easier to understand, can we either state that this currently behaves the same as Zero, or remove RobustBufferAccess for now?",
      "range": {
        "startLine": 61,
        "startChar": 2,
        "endLine": 61,
        "endChar": 20
      },
      "revId": "013938b34ca13f0f7dd02d2f5548114dd51469a3",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ecd4293_957746d4",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-11T08:43:24Z",
      "side": 1,
      "message": "I assume you mean that this could be used to read arbitrary process memory ranges, however I don\u0027t think this matches the implementation.\nThere\u0027s one edge case where we perform a masked-load with undef passthrough. I guess this is free to \u0027leak\u0027 data from the disabled lanes, but given the locality, this doesn\u0027t seem like a security issue.",
      "range": {
        "startLine": 62,
        "startChar": 56,
        "endLine": 62,
        "endChar": 66
      },
      "revId": "013938b34ca13f0f7dd02d2f5548114dd51469a3",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0648417_00381092",
        "filename": "src/Pipeline/SpirvShader.hpp",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 7183
      },
      "writtenOn": "2019-07-11T08:43:24Z",
      "side": 1,
      "message": "+ \", stores are elided.\"",
      "range": {
        "startLine": 62,
        "startChar": 54,
        "endLine": 62,
        "endChar": 55
      },
      "revId": "013938b34ca13f0f7dd02d2f5548114dd51469a3",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    }
  ]
}