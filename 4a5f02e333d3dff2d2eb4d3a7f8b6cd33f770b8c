{
  "comments": [
    {
      "key": {
        "uuid": "81d4cdb0_661499d2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 5005
      },
      "writtenOn": "2018-12-07T18:34:09Z",
      "side": 1,
      "message": "/",
      "range": {
        "startLine": 13,
        "startChar": 5,
        "endLine": 13,
        "endChar": 6
      },
      "revId": "4a5f02e333d3dff2d2eb4d3a7f8b6cd33f770b8c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a35129c_3ee49b5d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 5050
      },
      "writtenOn": "2018-12-07T20:58:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "81d4cdb0_661499d2",
      "range": {
        "startLine": 13,
        "startChar": 5,
        "endLine": 13,
        "endChar": 6
      },
      "revId": "4a5f02e333d3dff2d2eb4d3a7f8b6cd33f770b8c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "66582b27_2dc0c3e0",
        "filename": "src/Vulkan/VkImage.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 6982
      },
      "writtenOn": "2018-12-07T22:48:49Z",
      "side": 1,
      "message": "These guards don\u0027t seem quite adequate -- this code will misbehave when copying just the DEPTH aspect from a DEPTH+STENCIL image, as far as I can see?",
      "revId": "4a5f02e333d3dff2d2eb4d3a7f8b6cd33f770b8c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d10c96b8_ebfccf79",
        "filename": "src/Vulkan/VkImage.hpp",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 5005
      },
      "writtenOn": "2018-12-07T18:34:09Z",
      "side": 1,
      "message": "Just a general note, but this looks very object-oriented-y. Vulkan is a data-oriented API, meaning there are objects for holding data, and entities for performing operations on them and controlling the flow between them.\n\nAdding actions to the objects themselves like done here tends to decentralize things. In Vulkan, all commands are ultimately executed by the device.\n\nNot sure if this warrants any changes to this CL, but I just wanted to point this out as we want future versions to be efficient and not necessarily very object-oriented.",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 42,
        "endChar": 69
      },
      "revId": "4a5f02e333d3dff2d2eb4d3a7f8b6cd33f770b8c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e0872c0_8e01c0ce",
        "filename": "src/Vulkan/VkImage.hpp",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 5050
      },
      "writtenOn": "2018-12-07T20:58:10Z",
      "side": 1,
      "message": "Understood. I get how this would be very relevant to a system with multiple physical devices.\nI\u0027m trying to think of a case where the SwiftShader implementation would suffer from being object-oriented and I honestly can\u0027t think of one right now.\nI\u0027d rather not handle memory pointers outside of objects to keep any code handling memory pointers small and readable, for now.",
      "parentUuid": "d10c96b8_ebfccf79",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 42,
        "endChar": 69
      },
      "revId": "4a5f02e333d3dff2d2eb4d3a7f8b6cd33f770b8c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b005049_7fdbf5ee",
        "filename": "src/Vulkan/VkImage.hpp",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 5005
      },
      "writtenOn": "2018-12-08T14:55:21Z",
      "side": 1,
      "message": "It\u0027s quite easy for an object-oriented approach to start hurting us. Say we separate the implementation into a client and a server process. One image lives on the client side, the other on the server side (i.e. a \u0027staging\u0027 image and a \u0027device memory\u0027 image). So one might create a StagingImage and a DeviceImage subclass, with additional methods for copying between each of them, and make these methods virtual, and attempt to use IPC for calling them across the process boundary... While really it\u0027s still just a dumb memcpy() between buffers, from a data-oriented perspective.\n\nIf we just let Device handle the copy command by exposing the data pointers, it\u0027s less likely to become overly complex. Encapsulation only helps for implementation details that are not supposed to matter. Note that our sampler Reactor code also has direct access to the data, so I don\u0027t think it\u0027s very useful to hide it for copy operations.\n\nAnyway, I\u0027m not advocating for C spaghetti code where anything can access everything either. Object-oriented design has many valuable concepts and has its place in SwiftShader. I just think we have to be careful about the trade-offs and not blindly consider it the default go-to paradigm.",
      "parentUuid": "0e0872c0_8e01c0ce",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 42,
        "endChar": 69
      },
      "revId": "4a5f02e333d3dff2d2eb4d3a7f8b6cd33f770b8c",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}