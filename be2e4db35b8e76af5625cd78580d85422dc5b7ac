{
  "comments": [
    {
      "key": {
        "uuid": "39ac0498_b3ce76ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-07-20T19:09:57Z",
      "side": 1,
      "message": "It\u0027s great to know the root cause for the last remaining failures, but I\u0027m not sure this is the correct fix. It seems backwards that a test would pass when increasing our advertised precision, or rather, that it would start to fail again if we lowered it. Sure, this is closer to our actual precision (for small textures), but I think it\u0027s wrong for the test to fail if we report lower precision.\n\nI\u0027ll open an issue or two with Khronos to see if we can get the spec to clarify that higher effective precision is allowed, and adjust the tests.",
      "revId": "be2e4db35b8e76af5625cd78580d85422dc5b7ac",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3f20f15_87fde059",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-07-20T19:54:18Z",
      "side": 1,
      "message": "This is going to be difficult to do. The test performs linear filtering of mipmap levels, which are then interpolated based on the LOD.\nIn order to get this right, they\u0027d have to recursively retry the whole test at a progressively higher precision until it passes, and these tests are already somewhat time consuming, so we probably want to provide the test with a fairly good approximation of the precision we\u0027re using.\n\nAnyway, let\u0027s see how Khronos solves this.",
      "parentUuid": "39ac0498_b3ce76ba",
      "revId": "be2e4db35b8e76af5625cd78580d85422dc5b7ac",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c9212845_259b0bc1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-07-22T17:43:27Z",
      "side": 1,
      "message": "Khronos discussion: https://gitlab.khronos.org/vulkan/vulkan/-/issues/2276\n\nI don\u0027t think dEQP would have to retry multiple times. It could compute a high-precision reference result with floating-point math, as well as a low-precision one based on the claimed \u0027minimum\u0027 precision bits. The actual result should be within the range defined by these two.\n\nTo not pessimize performance for implementations which pass with the current tests, they could first compute the low-precision reference only, check if that\u0027s fine, and if not compute the high-precision one and do the range comparison.",
      "parentUuid": "a3f20f15_87fde059",
      "revId": "be2e4db35b8e76af5625cd78580d85422dc5b7ac",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eae43902_b789d3c9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5050
      },
      "writtenOn": "2020-07-22T19:31:47Z",
      "side": 1,
      "message": "Maybe they should just compute the full precision result and not the low precision one and adjust the threshold accordingly. Even if an implementation mentions supporting 4 bits of precision, does that mean \"16 equidistant possible texture coordinates between 0 and 1, starting at exactly 0\"? If it doesn\u0027t mention HOW the 4 bits should be used, then it\u0027s probably wrong for the test to assume anything based on the number of bits of precision alone.",
      "parentUuid": "c9212845_259b0bc1",
      "revId": "be2e4db35b8e76af5625cd78580d85422dc5b7ac",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "536500aa_1059f438",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5005
      },
      "writtenOn": "2020-07-22T19:52:48Z",
      "side": 1,
      "message": "\u003e Maybe they should just compute the full precision result and not the low precision one and adjust the threshold accordingly.\n\nThat would allow implementations which claim 8 bits of subtexel precision to pass the tests when in practice they only achieve 4 bits. If you meant adjusting the threshold according to the precision, that seems difficult to accomplish universally since it depends on the texel values too, and likely results in a wide threshold which allows actual bugs to slip through.\n\n\u003e Even if an implementation mentions supporting 4 bits of precision, does that mean \"16 equidistant possible texture coordinates between 0 and 1, starting at exactly 0\"?\n\nThe spec does spell that out exactly: \"2^subTexelPrecisionBits is the actual number of divisions along each axis of the image represented. Sub-texel values calculated during image sampling will snap to these locations when generating the filtered results.\"\n\nHowever, this is new in Vulkan. The OpenGL spec does not include such language, and the CTS determined the required precision. Vulkan was intended not to add new minimum requirements over GL. These dEQP tests have only started to fail between 1.1.6 and 1.2.1, so I don\u0027t think that\u0027s intentional. I appreciate that Vulkan defines how subtexel precision works, but the limit value should be a minimum not an exact number of bits retained.",
      "parentUuid": "eae43902_b789d3c9",
      "revId": "be2e4db35b8e76af5625cd78580d85422dc5b7ac",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": false
    }
  ]
}