{
  "comments": [
    {
      "key": {
        "uuid": "3ffe9ab8_a2ffaf01",
        "filename": "src/Pipeline/SpirvShaderDebugger.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1492,
      "author": {
        "id": 7183
      },
      "writtenOn": "2020-09-04T11:19:12Z",
      "side": 1,
      "message": "We\u0027re casting the `debug::Type::ID` down to an `debug::Object::ID` (which is the base of all debug classes), and checking that *any* debug object (type, scope, variables...) with the given ID exists.\n\nThe `get()` method just below does a `debug::cast\u003c\u003e` with the found object to check whether the object is of the requested type.\n\nI\u0027d recommend adding a `getOrNull()` which returns nullptr if the debug object isn\u0027t registered, but still asserts if the template type is incorrect:\n\n    template\u003ctypename T\u003e\n    T *SpirvShader::Impl::Debugger::getOrNull(SpirvID\u003cT\u003e id) const\n    {\n        auto it \u003d objects.find(debug::Object::ID(id.value()));\n        if (it \u003d\u003d objects.end()) { return nullptr; } // Not found.\n        auto ptr \u003d debug::cast\u003cT\u003e(it-\u003esecond.get());\n        ASSERT_MSG(ptr, \"Debug object %d is not of the correct type. Got: %s, want: %s\",\n                id.value(), cstr(it-\u003esecond-\u003ekind), cstr(T::KIND));\n        return ptr;\n    }",
      "range": {
        "startLine": 1489,
        "startChar": 0,
        "endLine": 1492,
        "endChar": 1
      },
      "revId": "4f39e2d51336cc84772c75b72bfe93d3e58e2133",
      "serverId": "aea13c4a-0b89-3eca-aee9-e193b1b77aa4",
      "unresolved": true
    }
  ]
}