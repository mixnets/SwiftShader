<!doctype html>
<!--
 Copyright 2020 The SwiftShader Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<html>

<head>
    <title>SwiftShader Code Coverage viewer</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.0/codemirror.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.0/theme/seti.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.0/codemirror.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.0/mode/clike/clike.min.js"></script>
    <script src=https://cdnjs.cloudflare.com/ajax/libs/jszip/3.2.2/jszip.min.js></script>

    <style>
        ::-webkit-scrollbar {
            background-color: #30353530;
        }

        ::-webkit-scrollbar-thumb {
            background-color: #80858050;
        }

        ::-webkit-scrollbar-corner {
            background-color: #00000000;
        }

        .frame {
            display: flex;
            left: 0px;
            right: 0px;
            top: 0px;
            bottom: 0px;
            position: absolute;
            font-family: monospace;
            background-color: #151515;
            color: #c0b070;
        }

        .left-pane {
            flex: 1;
        }

        .center-pane {
            flex: 3;
            min-width: 0;
            min-height: 0;
        }

        .top-pane {
            flex: 1;
            overflow: scroll;
        }

        .v-flex {
            display: flex;
            height: 100%;
            flex-direction: column;
        }

        .file-tree {
            font-size: small;
            overflow: auto;
            padding: 5px;
        }

        .test-tree {
            font-size: small;
            overflow: auto;
            padding: 5px;
        }

        .CodeMirror {
            flex: 3;
            height: 100%;
            border: 1px solid #eee;
        }

        .file-path {
            margin: 0px;
            white-space: nowrap;
            padding: 2px;
            margin-top: 1px;
            margin-bottom: 1px;
        }

        .file-path:hover {
            background-color: #303030;
            cursor: pointer;
        }

        .file-path.selected {
            background-color: #505050;
            color: #f0f0a0;
            cursor: pointer;
        }

        .test-name {
            margin: 0px;
            white-space: nowrap;
            padding: 2px;
            margin-top: 1px;
            margin-bottom: 1px;
        }

        .line-coverage {
            background-color: #20d04080;
            border-width: 0px 0px 0px 0px;
        }

        .line-coverage-start {
            border-left: solid 1px;
            border-color: #20f02080;
        }

        .line-coverage-end {
            border-right: solid 1px;
            border-color: #20f02080;
        }
    </style>
</head>

<body>
    <div class="frame">
        <div id="file_tree" class="left-pane file-tree"></div>
        <div class="center-pane">
            <div id="source" class="v-flex">
                <div class="top-pane">
                    <div class="test-tree" id="test_tree"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let before = (line, col, span) => {
            if (line < span[0]) { return true; }
            if (line == span[0]) { return col < span[1]; }
            return false;
        }
        let after = (line, col, span) => {
            if (line > span[2]) { return true; }
            if (line == span[2]) { return col > span[3]; }
            return false;
        }

        let el_file_tree = document.getElementById("file_tree");
        let el_test_tree = document.getElementById("test_tree");
        let el_source = CodeMirror(document.getElementById("source"), {
            lineNumbers: true,
            theme: "seti",
            mode: "text/x-c++src"
        });

        el_source.doc.setValue("// Downloading coverage... ");

        fetch("coverage.zip").then(response => response.arrayBuffer()).then(zipfile => {
            el_source.doc.setValue("// Unzipping coverage... ");
            JSZip.loadAsync(zipfile).then(function (zip) {
                zip.file("coverage.json").async("string").then(function (text) {
                    let json = JSON.parse(text);
                    el_source.doc.setValue("// Select file from the left... ");

                    let current_file = "";
                    let names = json.n;
                    let tests = json.t;
                    let spans = json.s;
                    let files = json.f;

                    let glob = (nodes, spanIDs) => {
                        nodes.forEach(node => {
                            let data = node[1];
                            if (data.s) {
                                data.s.forEach(spanID => spanIDs.add(spanID));
                            }
                            if (data.c) {
                                glob(data.c, spanIDs);
                            }
                        });
                    };

                    let markup = nodes => {
                        let spanIDs = new Set();
                        glob(nodes, spanIDs);
                        el_source.operation(() => {
                            spanIDs.forEach((spanID) => {
                                let span = spans[spanID];
                                el_source.doc.markText(
                                    { "line": span[0] - 1, "ch": span[1] - 1 },
                                    { "line": span[2] - 1, "ch": span[3] - 1 },
                                    {
                                        // inclusiveLeft: true,
                                        className: "line-coverage",
                                        startStyle: "line-coverage-start",
                                        endStyle: "line-coverage-end",
                                    });
                            });
                        });
                    };

                    let gather_tests = (coverage_nodes, test_nodes, from, to) => {
                        let list = [];
                        coverage_nodes.forEach(coverage_node => {
                            let index = coverage_node[0];
                            let coverage = coverage_node[1];
                            let test = test_nodes[index];
                            let test_id = test[0];
                            let test_children = test[1];
                            let test_name = names[test_id];

                            if (coverage.s) {
                                let match = coverage.s.some(spanID => {
                                    let span = spans[spanID];
                                    return !before(to.line + 1, to.ch + 1, span) && !after(from.line + 1, from.ch + 1, span)
                                });
                                if (match) {
                                    list.push(test_name + ".*");
                                    return;
                                }
                            }
                            if (coverage.c) {
                                list = list.concat(gather_tests(coverage.c, test_children, from, to).map(child_name => test_name + "." + child_name));
                            }
                        });
                        return list;
                    };

                    let load_source = (path) => {
                        for (let i = 0; i < el_file_tree.childNodes.length; i++) {
                            let el = el_file_tree.childNodes[i];
                            if (el.innerText == path) {
                                el.classList.add("selected");
                            } else {
                                el.classList.remove("selected");
                            }
                        }
                        el_source.doc.setValue("// Loading... ");
                        fetch("https://raw.githubusercontent.com/google/swiftshader/dc0f1319307ee723c6e8a09f2ac7efd9d7bf70c3/" + path)
                            .then(response => response.text())
                            .then(source => {
                                el_source.doc.setValue(source);
                                markup(files[path]);
                                current_file = path;
                            });
                    };

                    el_source.on("cursorActivity", () => {
                        if (current_file == "") { return; }
                        let from = el_source.doc.getCursor("from");
                        let to = el_source.doc.getCursor("to");
                        let filtered = gather_tests(files[current_file], tests, from, to);
                        el_test_tree.innerHTML = "";
                        filtered.forEach(test_name => {
                            let element = document.createElement('p');
                            element.className = "test-name";
                            element.innerText = test_name;
                            el_test_tree.appendChild(element);
                        });
                    });

                    Object.keys(files).forEach(path => {
                        let element = document.createElement('p');
                        element.className = "file-path";
                        element.innerText = path;
                        element.onclick = () => { load_source(path); }
                        el_file_tree.appendChild(element);
                    });
                });
            });
        });

    </script>
</body>

</html>